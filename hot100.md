# hot100
## 哈希
### 1.两数之和
``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(target - nums[i])) {
                return new int[] { map.get(target - nums[i]), i };
            }
            map.put(nums[i], i);
        }
        return new int[0];
    }
}
```

### 49.字母异位词分组
``` java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // 用排序好的字符串作为map的key值，value就是各种排序
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs) {
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            // 这里不能用 chars.toString() ，不然返回的是对象的类名加哈希码（内存地址的某种表示形式）。
            String key = new String(chars);
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            map.put(key, list);
        }
        // map.values() 返回的就是一个数组，map的每个value就是数组的一个元素
        return new ArrayList<>(map.values());
    }
}
```

### 128.最长连续序列
``` java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        int cur = 0, maxLen = 0, ans = 0;
        // 讲数组中所有元素放入Set中
        for (int num : nums) {
            set.add(num);
        }
        for (int i : set) {
            // 检测是否是连续序列的第一个值（最小值），如果是就重新开始计数
            if (!set.contains(i - 1)) {
                cur = i;
                maxLen = 1;
            }
            // 如果是连续序列的最小值，则开始往下计数
            while (set.contains(cur + 1)) {
                maxLen++;
                cur++;
            }
            ans = Math.max(maxLen, ans);
        }
        return ans;
    }
}
```

## 双指针
### 283.移动零
``` java
class Solution {
    public void moveZeroes(int[] nums) {
        // 快慢指针
        int slow = 0, fast = 0;
        while (fast < nums.length) {
            if (nums[fast] != 0) {
                nums[slow++] = nums[fast];
            }
            fast++;
        }
        while (slow < nums.length) {
            nums[slow++] = 0;
        }
    }
}
```

### 11.盛最多水的容器
``` java
class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int left = 0, right = n - 1;
        int ans = 0;
        while (left < right) {
            int w = right - left;
            int h = Math.min(height[left], height[right]);
            int area = w * h;
            ans = Math.max(ans, area);
            // 因为如果移动较大的一边，容器高度只可能变小或者不变（取小边为高度），宽度反而减少，容积一定减小
            // 如果左边数较小则左指针移动，右边数较小就右指针移动
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return ans;
    }
}
```

### 15.三数之和
``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        // 枚举 i
        for (int i = 0; i < n; i++) {
            // 如果 i 与上次重复，就直接省略，减少重复
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int k = n - 1;
            // 利用 j + k = -i 来寻找符合条件的 j 和 k
            int target = -nums[i];
            // 枚举 j
            for (int j = i + 1; j < n; j++) {
                // 如果 j 与上次重复，就直接省略，减少重复
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                // 保证 j 在 k 左边的同时不断将 k 左移，枚举 k
                while (j < k && nums[j] + nums[k] > target) {
                    k--;
                }
                // 如果 j 与 k 重叠，则说明这个 i 情况已经枚举完毕
                if (j == k) {
                    break;
                }
                // 如果等于，则加入ans中
                if (nums[j] + nums[k] == target) {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[k]);
                    ans.add(list);
                }
            }
        }
        return ans;
    }
}
```

### 42.接雨水
``` java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        // 左右指针
        int left = 0, right = n - 1;
        // 记录左边开始的最高柱子，和右边开始的最高柱子
        int leftMax = 0, rightMax = 0;
        int ans = 0;
        while (left < right) {
            // 如果左指针指的柱子更矮
            if (height[left] < height[right]) {
                // 更新左边开始的最高柱子
                leftMax = Math.max(leftMax, height[left]);
                // height[left]处能接的雨水则为 左边开始的最高柱子 和 当前左指针指的柱子 的高度差，即 leftMax - height[left] 
                ans += leftMax - height[left];
                // 移动左指针
                left++;
            } else {
                rightMax = Math.max(rightMax, height[right]);
                ans += rightMax - height[right];
                right--;
            }
        }
        return ans;
    }
}
```

## 滑动窗口
### 3.无重复字符的最长子串
``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // Set集合用来判断是否重复
        Set<Character> occ = new HashSet<>();
        int n = s.length();
        int ans = 0;
        // rk为滑动窗口的右边界
        int rk = -1;
        for (int i = 0; i < n; i++) {
            // 每次循环相当于滑动窗口左边界向右移动一格
            if (i != 0) {
                occ.remove(s.charAt(i - 1));
            }
            // rk在每次循环中不用重新 = -1，因为上一次循环 i 到 rk 无重复值，这一次 i + 1 到 rk 肯定也没有重复值
            while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {
                occ.add(s.charAt(rk + 1));
                rk++;
            }
            ans = Math.max(ans, rk - i + 1);
        }
        return ans;
    }
}
```

### 3.找到字符串中所有字母异位词
``` java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int sLen = s.length(), pLen = p.length();
        List<Integer> ans = new ArrayList<>();
        // 如果s长度小于p长度，则字符串s不可能包含p
        if (sLen < pLen) {
            return ans;
        }
        // 定义一个长度为pLen的滑动窗口，用数组记录这个窗口内每个字母的数量，再以字符串p内包含字母对比，来确定是否是字母异位词
        int[] sArr = new int[26];
        int[] pArr = new int[26];
        for (int i = 0; i < pLen; i++) {
            sArr[s.charAt(i) - 'a']++;
            pArr[p.charAt(i) - 'a']++;
        }
        // 用于判断滑动窗口初始位置是不是字母异位词
        if (Arrays.equals(sArr, pArr)) {
            ans.add(0);
        }
        for (int i = 0; i < sLen - pLen; i++) {
            // 不断将滑动窗口右移
            sArr[s.charAt(i) - 'a']--;
            sArr[s.charAt(i + pLen) - 'a']++;
            if (Arrays.equals(sArr, pArr)) {
                ans.add(i + 1);
            }
        }
        return ans;
    }
}
```

## 子串
### 560.和为K的子数组
``` java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int ans = 0;
        // 利用pre和一个哈希表来实现前缀和的效果
        int pre = 0; 
        Map<Integer, Integer> mp = new HashMap<>();
        // pre就相当于nums数组从0到i所有数字之和，利用之前哈希表做的做成的前缀和表，实现 pre - 某前缀和 = k 这个式子的变形，来判断子串和为k
        mp.put(0, 1);
        for (int i = 0; i < n; i++) {
            pre += nums[i];
            // 哈希表存放的是数组到i为止所有的前缀和，以及出现的次数，如果哈希表存在 pre - k ，即子串和为k
            if (mp.containsKey(pre - k)) {
                ans += mp.get(pre - k);
            }
            mp.put(pre, mp.getOrDefault(pre, 0) + 1);
        }
        return ans;
    }
}
```

### 239.滑动窗口最大值
``` java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        // 用队列来实现滑动窗口
        Deque<Integer> deque = new LinkedList<>();
        // 滑动窗口中存放数组下标，利用 deque.peekFirst() <= i - k 这个特性可以实现提前删去不可能的值并且实现单调队列
        for (int i = 0; i < k; i++) {
            // 第一个滑动窗口，如果 nums[i] <= nums[j] 并且 i < j 则 i 可以直接删去，保证滑动窗口第一个就是该滑动窗口最大值
            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
                deque.pollLast();
            }
            deque.offerLast(i);
        }
        ans[0] = nums[deque.peekFirst()];
        for (int i = k; i < n; i++) {
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            deque.offerLast(i);
            // 如果当前滑动窗口第一个已经超出滑动窗口范围，则删去
            if (deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            ans[i - k + 1] = nums[deque.peekFirst()];
        }
        return ans;
    }
}
```

### 76.最小覆盖子串
``` java
class Solution {
    // 用哈希表存储某段字符串中每个字母的数量
    Map<Character, Integer> tMap = new HashMap<>();
    // 用来储存滑动窗口中有与 t字符串 中相同的字母
    Map<Character, Integer> sMap = new HashMap<>();

    public String minWindow(String s, String t) {
        int tLen = t.length();
        int sLen = s.length();
        // 用 字符串t 里的各字母数量做哈希表，用来对比是否是子串
        for (int i = 0; i < tLen; i++) {
            char c = t.charAt(i);
            tMap.put(c, tMap.getOrDefault(c, 0) + 1);
        }
        int l = 0, r = -1;
        // len是用来记录目前位置的最小长度
        int len = Integer.MAX_VALUE;
        int ansL = -1, ansR = -1;
        while (r < sLen) {
            // 每次循环将滑动窗口右边界右移
            r++;
            // 如果右边界扩充到的字母在 字符串t 中有，则添加到 sMap 中
            if (r < sLen && tMap.containsKey(s.charAt(r))) {
                sMap.put(s.charAt(r), sMap.getOrDefault(s.charAt(r), 0) + 1);
            }
            // 如果滑动窗口已经包含 字符串t 中全部字母，并且滑动窗口左边界还没越过有边界
            while (check() && l <= r) {
                // 如果 当前长度 小于 最小长度
                if (r - l + 1 < len) {
                    // 更新最小长度，并将答案左边界有边界更新
                    len = r - l + 1;
                    ansL = l;
                    ansR = l + len;
                }
                // 将滑动窗口左边界向左移动，并移除左边界的字母
                if (tMap.containsKey(s.charAt(l))) {
                    sMap.put(s.charAt(l), sMap.getOrDefault(s.charAt(l), 0) - 1);
                }
                l++;
            }
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR);
    }

    // 检查方法，用迭代器遍历哈希表，用来检查 sMap 是否已经包含 tMap 中的所有字母
    private boolean check() {
        Iterator iter = tMap.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            Character key = (Character) entry.getKey();
            Integer val = (Integer) entry.getValue();
            if (sMap.getOrDefault(key, 0) < val) {
                return false;
            }
        }
        return true;
    }
}
```

## 普通数组
### 53.最大子数组和
``` java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int ans = nums[0];
        // dp数组含义：dp[i]表示从0到i最大子数组和
        int[] dp = new int[n];
        dp[0] = nums[0];
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```

### 56.合并区间
``` java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 先根据数组第一位数字进行排序
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        int n = intervals.length;
        List<int[]> ans = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            // 如果前一个区间完全在后一个区间的前面没有重叠，如 [1][3] 到 [5][6] 
            if (intervals[i - 1][1] < intervals[i][0]) {
                ans.add(intervals[i - 1]);
            } else {
                // 如果有重叠，如 [1][3] 到 [2][6]，前一个范围第二位 3 比 后一个范围第一位 2 要大，所以将后一个范围第一位改为较大的 3
                intervals[i][0] = intervals[i - 1][0];
                // 后一个范围第二位则取两个范围第二位中的较大值
                intervals[i][1] = Math.max(intervals[i - 1][1], intervals[i][1]);
            }
        }
        // 因为一直加入ans中的是前一个范围，所以最后会剩下一个范围，也要加入ans
        ans.add(intervals[n - 1]);
        return ans.toArray(new int[ans.size()][]);
    }
}
```

### 189.轮转数组
``` go
func rotate(nums []int, k int) {
    n := len(nums)
    k = k % n  // 处理 k 大于数组长度的情况
    count := 0 // 记录已经替换的元素个数

    // 遍历数组，直到所有元素都被替换
    for start := 0; count < n; start++ {
        cur := start
        prev := nums[start] 

        // 环状替换
        for {
            next := (cur + k) % n // 计算下一个位置
            nums[next], prev = prev, nums[next] // 交换元素
            cur = next
            count++

            // 如果回到起点，结束当前环
            if cur == start {
                break
            }
        }
    }
}
```

### 238.除自身以外数组的乘积
``` java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        // 先遍历一遍，ans[i] 含义为 nums[0] * nums[1] * ... * nums[i - 1]
        ans[0] = 1;
        for (int i = 1; i < n; i++) {
            ans[i] = ans[i - 1] * nums[i - 1];
        }

        // 用一个 R 来代替 R[] 数组，R[i] 为 nums[n - 1] * nums[n] * ... * nums[i + 1]
        int R = 1;
        for (int i = n - 1; i >= 0; i--) {
            ans[i] *= R;
            // 不断更新R
            R *= nums[i];
        }
        return ans;
    }
}
```

### 41.缺失的第一个正数
``` go
// 这题最重要的就是理解缺失的最小正整数只能在 1 到 n + 1 之中
// 因为数组就那么长，一共放 n 个数
func firstMissingPositive(nums []int) int {
    n := len(nums)
    // 先将原本的负数都变成 n + 1，即接下来的排序其实和这些数无关了
    for i := 0; i < n; i++ {
        if nums[i] <= 0 {
            nums[i] = n + 1
        }
    }
    // 将每一个小于 n + 1 的数取出，减一并变成下标，下标对应数组中的数再变为负数
    // 其实本质就是，把小于 n + 1 的数，拿出来排序，从 1 到 n + 1，中间少了哪一个，就是第一个正数
    for i := 0; i < n; i++ {
        num := abs(nums[i])
        if num <= n {
            nums[num - 1] = -abs(nums[num - 1]);
        }
    }
    for i := 0; i < n; i++ {
        if nums[i] >= 0 {
            return i + 1;
        }
    }
    return n + 1;
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```

## 矩阵
### 73.矩阵置零
``` java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        // 用标记数组，记录哪一行哪一列有0
        boolean[] row = new boolean[m];
        boolean[] col = new boolean[n];

        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (matrix[i][j] == 0)
                    row[i] = col[j] = true;

        // 再根据标记数组，来把有0的行列都变为0
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (row[i] || col[j])
                    matrix[i][j] = 0;
    }
}
``` 

### 54.螺旋矩阵
``` go
func spiralOrder(matrix [][]int) []int {
	rows, cols := len(matrix), len(matrix[0])
	visited := make([][]bool, rows)
	for i := 0; i < rows; i++ {
		visited[i] = make([]bool, cols)
	}

	var (
		total = rows * cols
		ans = make([]int, total)
		row, col = 0, 0
        // 方向数组
		directions = [][]int{[]int{0, 1}, []int{1, 0}, []int{0, -1}, []int{-1, 0}}
        // 方向指数，一开始是0，即[0][1]，即向右
		directionIndex = 0
	)

	for i := 0; i < total; i++ {
		ans[i] = matrix[row][col]
        // visited数组记录矩阵中访问过的元素
		visited[row][col] = true
        // 先按目前的方向往下推一格
		nextRow, nextCol := row + directions[directionIndex][0], col + directions[directionIndex][1]
        // 如果往下推一格，发现超出边界，或者是已经访问过的元素，就换方向
        // 已经访问过的元素就是你之前转过的圈
		if nextRow < 0 || nextRow >= rows || nextCol < 0 || nextCol >= cols || visited[nextRow][nextCol] {
            // 将方向指数加一，比如从 [0][1] 到 [1][0]，即从向右到向下
			directionIndex = (directionIndex + 1) % 4
		}
		row += directions[directionIndex][0]
		col += directions[directionIndex][1]
	}

	return ans
}
```

### 48.旋转图像
``` go
func rotate(matrix [][]int) {
	n := len(matrix)
	for i := 0; i < n / 2; i++ {
		for j := 0; j < (n + 1) / 2; j++ {
            // 旋转图像，从几个角开始旋转
            temp := matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
		}
	}
}
```

### 240.搜索二维矩阵 II
``` go
// Z字查询
func searchMatrix(matrix [][]int, target int) bool {
    rows, cols := len(matrix), len(matrix[0])
    x, y := 0, cols - 1
    for x < rows && y >= 0 {
        if matrix[x][y] == target {
            return true
        }
        // 从左上角开始，先不断减少y，寻找到 target 所在的那一列
        if matrix[x][y] > target {
            y--
        // 然后不断减少x，找到target
        } else {
            x++
        }
    }
    return false
}
```

## 链表
### 160.相交链表
``` java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // Set集合用来记录某一条链表上的所有结点
        Set<ListNode> set = new HashSet<>();
        ListNode node = headA;
        // 将A链表上所有结点加入Set中
        while (node != null) {
            set.add(node);
            node = node.next;
        }
        node = headB;
        // 遍历B链表，如果有结点存在于Set集合中，说明两链表相交
        while (node != null) {
            if (set.contains(node)) {
                return node;
            }
            node = node.next;
        }
        return null;
    }
}
```

### 206.反转链表
``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        // 定义两个指针，前指针指向头节点前一个，后指针指向头节点
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            // 新定义一个指针，指向后指针的下一个
            ListNode next = cur.next;
            // 将 后指针的下一个 从往后改为往前
            cur.next = pre;
            // 将 前指针指向的 改为 后指针指向 的
            pre = cur;
            // 将 后指针 往后移
            cur = next;
        } 
        return pre;
    }
}
```

### 234.回文链表
``` java
class Solution {
    ListNode frontPointer;

    public boolean isPalindrome(ListNode head) {
        frontPointer = head;
        return recurse(head);
    }

    // 通过递归方法检查是否回文
    private boolean recurse(ListNode curPointer) {
        if (curPointer != null) {
            // 通过递归一直将cur指针后移到最后一个结点
            if (!recurse(curPointer.next)) {
                return false;
            }
            // 比较cur指针和front指针结点的值是否一致，即前后是否一致
            if (curPointer.val != frontPointer.val) {
                return false;
            }
            // 将前指针向后移动
            frontPointer = frontPointer.next;
        }
        // 通过递归，将后指针前移   
        return true;
    }
}
``` 

### 141.环形链表
``` java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false; // 链表为空或只有一个节点，无环
        }
        ListNode slow = head;
        ListNode fast = head;
        // 快慢指针遍历
        while (fast != null && fast.next != null) {
            slow = slow.next; // 慢指针走一步
            fast = fast.next.next; // 快指针走两步
            // 如果快慢指针相遇，说明有环
            if (slow == fast) {
                return true;
            }
        }
        return false; // 无环
    }
}
``` 

### 142.环形链表 II
``` java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null; // 链表为空或只有一个节点，无环
        }
        ListNode slow = head;
        ListNode fast = head;
        // 快慢指针遍历
        while (fast != null && fast.next != null) {
            slow = slow.next;          // 慢指针走一步
            fast = fast.next.next;      // 快指针走两步
            // 如果快慢指针相遇，说明有环
            if (slow == fast) {
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null; // 无环
    }
}
```

### 21.合并两个有序链表
``` java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 虚拟头节点，用来保存头节点的地址，后续方便return
        ListNode dummyHead = new ListNode(-1);
        // 遍历链表的指针
        ListNode ptr = dummyHead;
        // 将 list1 和 list2 按大小接到 新链表的后边，直到有一个链表全部遍历完
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                ptr.next = list1;
                list1 = list1.next;
            } else {
                ptr.next = list2;
                list2 = list2.next;
            }
            ptr = ptr.next;
        }
        // 将另一个没遍历完的链表，整个直接接到新链表后面
        ptr.next = list1 == null ? list2 : list1;
        return dummyHead.next;
    }
}
```

### 2.两数相加
``` java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode();
        ListNode ptr = dummyHead;
        int carry = 0;
        // 只要l1和l2有一个不为空或者上一位有进位，就要继续向后推一位
        while (l1 != null || l2 != null || carry != 0) {
            // 获取l1和l2相应位数的数字
            int num1 = l1 != null ? l1.val : 0;
            int num2 = l2 != null ? l2.val : 0;
            // 还需要加上上一位进位的数字
            int sum = num1 + num2 + carry;

            // 将加起来的数字连到新链表后边
            ptr.next = new ListNode(sum % 10);
            ptr = ptr.next;

            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
            
            // 判断加起来的数字有没有超过9，超过了就要进位
            carry = sum >= 10 ? 1 : 0;
        }

        return dummyHead.next;
    }
}
```

### 19.删除链表的倒数第 N 个结点
``` java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1, head);
        ListNode fast = dummy, slow = dummy;
        // 通过快慢指针来找到倒数第 n 个结点
        while (fast.next != null) {
            // 先让快指针比慢指针快 n 个结点
            if (n > 0) {
                fast = fast.next;
                n--;
            // 然后两个指针一起往后移，当快指针到最后一个结点时，慢指针指着的就是倒数第 n 个结点
            } else {
                fast = fast.next;
                slow = slow.next;
            }
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```

### 24.两两交换链表中的节点
``` java
class Solution {
    public ListNode swapPairs(ListNode head) {
        // 虚拟头节点
        ListNode dummyHead = new ListNode(-1);
        dummyHead.next = head;
        // 遍历指针
        ListNode ptr = dummyHead;
        // 从表头开始，每次遍历两个，如果有两个就交换
        // 如 dummyHead(ptr) -> node1 -> node2 -> node3
        while (ptr.next != null && ptr.next.next != null) {
            ListNode node1 = ptr.next;
            ListNode node2 = ptr.next.next;
            // ptr -> node2 -> node3 
            ptr.next = node2;
            // ptr -> node2 -> node3 <- node1
            node1.next = node2.next;
            // ptr -> node2 -> node1 -> node3
            node2.next = node1;
            /// node2 -> node1(ptr) -> node3
            ptr = node1;
        }
        return dummyHead.next;
    }
}
```

### 25.K 个一组翻转链表
``` java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode pre = dummyHead;

        while (head != null) {
            ListNode tail = pre;
            // 查看剩余部分长度是否大于等于 k
            for (int i = 0; i < k; ++i) {
                tail = tail.next;
                if (tail == null) {
                    return dummyHead.next;
                }
            }
            ListNode nex = tail.next; // 记录下一个部分的头
            ListNode[] reverse = myReverse(head, tail);
            head = reverse[0];
            tail = reverse[1];
            // 把子链表重新接回原链表
            pre.next = head;
            tail.next = nex;
            pre = tail;
            head = tail.next;
        }

        return dummyHead.next;
    }

    public ListNode[] myReverse(ListNode head, ListNode tail) {
        ListNode prev = tail.next; // 记录尾节点之后的节点
        ListNode cur = head;

        // 逐个反转链表
        while (cur != tail) {
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }

        // 处理最后一个节点 tail
        tail.next = prev;

        return new ListNode[] { tail, head }; // tail 变成新的头，head 变成新的尾
    }
}
```

### 138.随机链表的复制
``` java
class Solution {
    // 用一个 Map 来存储已经创造过的节点
    Map<Node, Node> cachedMap = new HashMap<>();

    public Node copyRandomList(Node head) {
        if (head == null) return null;
        // 将没创造过的节点加入到 Map 中
        if (!cachedMap.containsKey(head)) {
            Node newNode = new Node(head.val);
            cachedMap.put(head, newNode);
            newNode.next = copyRandomList(head.next);
            newNode.random = copyRandomList(head.random);
        }
        // 如果已经创造过，就直接从 Map 中取
        return cachedMap.get(head);
    }
}
```

### 148.排序链表
``` java
class Solution {
    public ListNode sortList(ListNode head) {
        return sort(head, null);
    }

    // 本质是不断将链表分成两半，然后分到最小，排序，然后合并
    ListNode sort(ListNode head, ListNode tail) {
        if (head == null) return head;
        // 说明被分割到只有两个结点了
        if (head.next == tail) {
            head.next = null;
            return head;
        }
        // 用快慢指针，快指针一次走两个，慢指针一次走一个，快指针走到末尾，慢指针就在中间
        ListNode slow = head, fast = head;
        while (fast != tail) {
            slow = slow.next;
            fast = fast.next;
            if (fast != tail) fast = fast.next;
        }
        // 从中间将链表分成两半
        ListNode mid = slow;
        // 将两半都各自再次分割
        ListNode list1 = sort(head, mid);
        ListNode list2 = sort(mid, tail);
        // 排序并合并好两段链表
        ListNode sorted = merge(list1, list2);
        return sorted;
    }

    // 排序其实是在合并方法里的，详见 题目21 ，完全一样
    ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummyHead = new ListNode(0);
        ListNode temp = dummyHead, temp1 = head1, temp2 = head2;
        while (temp1 != null && temp2 != null) {
            if (temp1.val <= temp2.val) {
                temp.next = temp1;
                temp1 = temp1.next;
            } else {
                temp.next = temp2;
                temp2 = temp2.next;
            }
            temp = temp.next;
        }
        if (temp1 != null) {
            temp.next = temp1;
        } else if (temp2 != null) {
            temp.next = temp2;
        }
        return dummyHead.next;
    }
}
```

### 23.合并 K 个升序链表
``` java
// 如果想用时间复杂度小的方法，就是把所有结点依次加入顺序队列中，然后依次取出来组成链表
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode ans = null;
        for (int i = 0; i < lists.length; i++) 
            ans = merge(ans, lists[i]);
        return ans;
    }

    // 合并两个有序链表，详见题目21
    public ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummyHead = new ListNode(0);
        ListNode temp = dummyHead, temp1 = head1, temp2 = head2;
        while (temp1 != null && temp2 != null) {
            if (temp1.val <= temp2.val) {
                temp.next = temp1;
                temp1 = temp1.next;
            } else {
                temp.next = temp2;
                temp2 = temp2.next;
            }
            temp = temp.next;
        }
        if (temp1 != null) {
            temp.next = temp1;
        } else if (temp2 != null) {
            temp.next = temp2;
        }
        return dummyHead.next;
    }
}
```

### 146.LRU 缓存
``` java
// 哈希表＋双向链表 实现LRU缓存
// 双向链表节点存储的是键值对
// 哈希表的键就是双向链表节点的键，哈希表的值就是双向链表节点
// HashMap<key, <key, value>>
class LRUCache {
    // 双向链表节点定义
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    // 私有属性
    private Map<Integer, DLinkedNode> cache = new HashMap<>();
    // 长度
    private int size;
    // 容量
    private int capacity;
    // 虚拟头尾节点，真正第一个节点从虚拟投节点的下一个开始
    private DLinkedNode head, tail;

    // 构造方法
    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.next = head;
    }
    
    public int get(int key) {
        // 从哈希表中快速寻找是否有这个key
        DLinkedNode node = cache.get(key);
        // 如果没有直接返回-1
        if (node == null) return -1;
        // 如果有则先将该节点移至头部，再返回该节点value
        moveToHead(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        // 先检查该 key 是否已经存在
        DLinkedNode node = cache.get(key);
        // 如果没有，则添加
        if (node == null) {
            // 根据 key-value 创建新的双向链表节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // key key value 结构
            // 添加到哈希表中
            cache.put(key, newNode);
            // 添加到双向链表头部
            addToHead(newNode);
            // 增加长度
            size++;
            // 如果长度超过容量，则删除尾部节点
            if (size > capacity) {
                // 在双向链表中删除
                DLinkedNode tail = removeTail();
                // 在哈希表中删除
                cache.remove(tail.key);
                size--;
            }
        } 
        // 如果 key 已经存在
        else {
            // 修改 key 对应的 value，然后将节点移至头部
            node.value = value;
            moveToHead(node);
        }
    }

    // 从头部添加节点（即从虚拟头节点head后添加节点）
    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    // 删除某个节点
    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    // 将某个节点移至最前面
    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    // 删除尾部节点（即删去虚拟尾节点tail的前一个节点）
    private DLinkedNode removeTail() {
        DLinkedNode node = tail.prev;
        removeNode(node);
        // 之所以需要返回这个被删除的节点，是因为需要他来定位哈希表中该节点，然后在哈希表中也删除
        return node;
    }
}
```

## 二叉树
### 94.二叉树的中序遍历
``` java
class Solution {
    List<Integer> ans;

    public List<Integer> inorderTraversal(TreeNode root) {
        ans = new ArrayList<Integer>();
        traversal(root);
        return ans;
    }

    // 递归遍历法
    void traversal(TreeNode node) {
        if (node == null) {
            return;
        }
        // 中序遍历，先左，再中，再右
        traversal(node.left);
        ans.add(node.val);
        traversal(node.right);
    }
}
```

### 104.二叉树的最大深度
``` java
class Solution {
    public int maxDepth(TreeNode root) {
        return traversal(root);
    }

    public int traversal(TreeNode node) {
        if (node == null) {
            return 0;
        }
        // 左树高度
        int leftHeight = traversal(node.left);
        // 右树高度
        int rightHeight = traversal(node.right);
        // 取较大者再加一，即目前结点的高度
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

### 226.翻转二叉树
``` java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        traversal(root);
        return root;
    }

    public void traversal(TreeNode pointer) {
        if (pointer == null) {
            return;
        }
        // 遍历整个二叉树，将每个结点的左右子树交换
        TreeNode tmp = pointer.left;
        pointer.left = pointer.right;
        pointer.right = tmp;
        traversal(pointer.left);
        traversal(pointer.right);
    }
}
```

### 101.对称二叉树
``` java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return compare(root.left, root.right);
    }

    // 左右对比
    public boolean compare(TreeNode left, TreeNode right) {
        // 如果左节点为空，右节点不为空，则不对称
        if (left == null && right != null)
            return false;
        // 如果左节点不为空，右节点为空，则不对称
        else if (left != null && right == null)
            return false;
        // 如果左右结点都为空，说明对称，并下面没有需要比较的内容了，终止递归
        else if (left == null && right == null)
            return true;
        // 如果左右结点 value 不一样，则不对称
        else if (left.val != right.val)
            return false;
        // 对比每个结点的外侧结点
        boolean compareOutside = compare(left.left, right.right);
        // 对比每个结点的内侧结点
        boolean compareInside = compare(left.right, right.left);
        // 如果外侧内测都相同，则返回相同
        return compareOutside && compareInside;
    }
}
``` 

### 543.二叉树的直径
``` java
 */
class Solution {
    private int diameter;

    public int diameterOfBinaryTree(TreeNode root) {
        getDepth(root);
        return diameter;
    }

    public int getDepth(TreeNode node) {
        if (node == null)
            return 0;
        // 获取左子树高度和右子树高度
        int leftDepth = getDepth(node.left);
        int rightDepth = getDepth(node.right);
        // 左右子树高度之和 即该树任意两个节点之间最长路径的长度（二叉树的直径）
        diameter = Math.max(diameter, leftDepth + rightDepth);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
``` 

### 102.二叉树的层序遍历
``` java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        // 先将第一层（即头结点）加入到队列中
        if (root != null)
            queue.add(root);
        while (!queue.isEmpty()) {
            // 记录该层的节点数
            int size = queue.size();
            List<Integer> path = new ArrayList<>();
            // 如果该层节点数归零，说明该层节点已经遍历完了，切换到下一层
            while (size > 0) {
                // 从左到右把每个节点从队列中拿出来
                TreeNode node = queue.poll();
                path.add(node.val);
                // 然后把该节点的左右子节点添加到队列中，作为下一层节点
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
                size--;
            }
            ans.add(path);
        }
        return ans;
    }
}
```

### 108.将有序数组转换为二叉搜索树
``` java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return traversal(nums, 0, nums.length - 1);
    }

    TreeNode traversal(int[] nums, int left, int right) {
        if (left > right)
            return null;
        int mid = left + (right - left) / 2;
        // 因为是有序数组，所以数组的中间数就是二叉搜索树的根节点
        TreeNode node = new TreeNode(nums[mid]);
        // 然后数组中间数左边的就继续构成根节点左子树
        node.left = traversal(nums, left, mid - 1);
        // 数组中间数右边的就构成根节点右子树
        node.right = traversal(nums, mid + 1, right);
        return node;
    }
}
```

### 98.验证二叉搜索树
``` java
class Solution {
    // 前结点，用来遍历的时候记录当前遍历的前一个结点
    TreeNode pre = null;

    public boolean isValidBST(TreeNode root) {
        return isValid(root);
    }

    boolean isValid(TreeNode node) {
        if (node == null)
            return true;

        // 标准中序遍历，因为是二叉搜索树，所以中序遍历出来的顺序一定是从小到大的
        boolean left = isValid(node.left);

        // pre是当前遍历的前一个结点，与当前结点进行比较，如果出现当前节点小于等于前一个结点，说明有错
        if (pre != null && node.val <= pre.val) 
            return false;
        // 将前一个结点指向现在这个结点
        pre = node;

        boolean right = isValid(node.right);
        
        return left && right;
    }
}
```

### 230.二叉搜索树中第 K 小的元素
``` java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<>();
        // 用迭代法来中序遍历，方便停止
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            // 当 k == 0 时，就找到第 K 小的结点了
            k--;
            if (k == 0) break;
            root = root.right;
        }
        return root.val;
    }
}
```

### 199.二叉树的右视图
``` java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        // ArrayDeque 的 push() 方法是添加到栈顶，最先被弹出，即后进先出
        // ArrayDeque 的 add() 方法是添加到栈尾，最后被弹出，即先进后出
        Deque<TreeNode> queue = new ArrayDeque<>();
        List<Integer> ans = new ArrayList<>();
        if (root == null) return ans;
        // 层序遍历，然后取每层的最右边一个即可
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            ans.add(queue.peek().val);
            while (size-- > 0) {
                TreeNode node = queue.pop();
                if (node.right != null) queue.add(node.right);
                if (node.left != null) queue.add(node.left);
            }
        }
        return ans;
    }
}
```

### 114.二叉树展开为链表
``` java
class Solution {
    // 该题也可以直接前序遍历把节点都放在一个List里面，然后再重新建一棵树
    public void flatten(TreeNode root) {
        while (root != null) {
            // 如果节点左边没有节点了，就直接继续往右遍历
            if (root.left == null) 
                root = root.right;
            // 如果节点左右还有节点
            else {
                // 将该节点的 左节点 和 左节点的所有右节点 全都插入到 该节点和该节点的右节点中间
                TreeNode pre = root.left;
                while (pre.right != null)
                    pre = pre.right;
                pre.right = root.right;
                root.right = root.left;
                root.left = null;
            }
        }
    }
}
```

### 105.从前序与中序遍历序列构造二叉树
``` java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return myBuildTree(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);
    }

    private TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) return null;
        // 前序遍历第一个结点就是根节点
        int preorder_root = preorder[preorder_left];
        TreeNode root = new TreeNode(preorder_root);
        // 在中序遍历中定位根节点
        int inorder_root;
        for (inorder_root = inorder_left; inorder_root <= inorder_right; inorder_root++)
            if (inorder[inorder_root] == preorder_root) 
                break;
        // 在中序遍历中，根据根结点将数组分成两部分，左边部分就是根结点左子树，右边部分是根节点右子树
        // 左子树起始位置
        int inorder_left_begin = inorder_left;
        // 左子树最终位置（根节点左边）
        int inorder_left_end = inorder_root - 1;
        // 右子树起始位置（根节点右边）
        int inorder_right_begin = inorder_root + 1;
        // 右子树最终位置
        int inorder_right_end = inorder_right;

        // 前序遍历中，顺序是中左右，可以根据中序遍历算出中一个，左多少个，右多少个
        // 左部分，起点就是根节点右边一位
        int preorder_left_begin = preorder_left + 1;
        // 左部分终点可以根据，中序遍历中左子树节点数量算出
        int preorder_left_end = preorder_left_begin + inorder_left_end - inorder_left_begin;
        // 右部分起点自然就是左部分终点右边一位
        int preorder_right_begin = preorder_left_end + 1;
        // 右部分终点，可以用中序遍历算出右子树的节点数量，也可是前序遍历最右边
        int preorder_right_end = preorder_right;

        root.left = myBuildTree(preorder, inorder, preorder_left_begin, preorder_left_end, inorder_left_begin, inorder_left_end);
        root.right = myBuildTree(preorder, inorder, preorder_right_begin, preorder_right_end, inorder_right_begin, inorder_right_end);

        return root;
    }
}
```

### 437.路径总和 III
``` go
func rootSum(root *TreeNode, targetSum int) int {
    res := 0
    if root == nil {
        return res
    }
    val := root.Val
    // 如果 val == targetSum，说明目前路径和已经等于target了，则返回值加一
    if val == targetSum {
        res++
    }
    // 继续从目前节点往下找，然后 target 要减去目前节点的值
    // 即使目前路径和已经等于 target 了，也要继续往下找，因为节点有负值，可能下一个是 -1，在下一个是 1
    res += rootSum(root.Left, targetSum - val)
    res += rootSum(root.Right, targetSum - val)
    return res
}

func pathSum(root *TreeNode, targetSum int) int {
    if root == nil {
        return 0
    }
    // 从 root 节点开始遍历，返回路径和为target的路径数量
    res := rootSum(root, targetSum)
    // 从 root 的左子节点开始遍历
    res += pathSum(root.Left, targetSum)
    // 从 root 的右子节点开始遍历
    res += pathSum(root.Right, targetSum)
    return res
}
```

### 236.二叉树的最近公共祖先
``` java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return dfs(root, p, q);
    }

    private TreeNode dfs(TreeNode node, TreeNode p, TreeNode q) {
        // 往下搜索，到底层开始返回，如果一直没找到，就一直往上返回null
        if (node == null)
            return null;
        // 如果找到了p结点或者q结点，说明公共祖先要么是这个结点，要么还在这个结点上面，就不用继续往下搜索了
        // 如果找到了p结点，但是q结点在p结点更下层怎么办？不用管往上传，如果另一边没找到，那p结点就是公共祖先了
        if (node.val == p.val || node.val == q.val)
            return node;
        // 往左下边搜索
        TreeNode left = dfs(node.left, p, q);
        // 往右下边搜索
        TreeNode right = dfs(node.right, p, q);
        // 如果左右返回过来的值都不是null，说明该结点就是公共祖先，将该节点一直网上传递即可
        if (left != null && right != null)
            return node;
        
        // 如果只有一边传过来不是null，就将那一边传上来的结点一直往上传
        if (left == null && right != null)
            return right;
        else if (left != null && right == null)
            return left;
        else
            return null;
    }
}
```

### 124.二叉树中的最大路径和
``` java
class Solution {
    private int ans = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }

    // 最大路径和，本质是求 当前节点 Val 加上 左子树最大路径和 和 右子树最大路径和
    private int dfs(TreeNode node) {
        if (node == null) return 0;
        // 因为有负值，所以要判断子树最大深度是否大于0，如果没有就不要了
        int leftPathSum = Math.max(dfs(node.left), 0);
        int rightPathSum = Math.max(dfs(node.right), 0);
        int val = node.val;
        int curPathSum = val + leftPathSum + rightPathSum; 
        ans = Math.max(ans, curPathSum);
        // 返回给上一层目前最长的路径和
        return val + Math.max(leftPathSum, rightPathSum);
    }
}
```

## 图论
### 200.岛屿数量
``` javascript
var numIslands = function (grid) {
    if (grid === null || grid.length === 0) {
        return 0;
    }

    let H = grid.length;
    let W = grid[0].length;
    let ans = 0;

    // 遍历整个grid，如果遇到 ‘1’，则调用 dfs 方法将 和该‘1’一座岛的‘1’全部变为‘0’
    for (let i = 0; i < H; i++) {
        for (let j = 0; j < W; j++) {
            if (grid[i][j] === '1') {
                ans++;
                dfs(i, j);
            }
        }
    }

    function dfs(h, w) {
        // ‘1’ 附近扩散至边界或者 ’0‘ 处停止
        if (h < 0 || h >= H || w < 0 || w >= W || grid[h][w] === '0') {
            return;
        }

        grid[h][w] = '0';
        // 向上下左右扩散
        dfs(h + 1, w);
        dfs(h - 1, w);
        dfs(h, w + 1);
        dfs(h, w - 1);
    };

    return ans;
};
```

### 994.腐烂的橘子
``` java
class Solution {
        public int orangesRotting(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int total = 0;
        // 用队列储存烂橘子位置
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++) {
                // 计算出所以橘子的数量，包括好橘子和烂橘子
                if (grid[i][j] > 0) 
                    total++;
                // 如果是烂橘子就把位置存入队列中
                if (grid[i][j] == 2)
                    queue.add(new int[]{i, j});
            }

        int rotten = 0;
        int minutes = -1;
        int[] dx = new int[]{-1, 0, 1, 0};
        int[] dy = new int[]{0, 1, 0, -1};
        while (!queue.isEmpty()) {
            // 上层循环每一次循环代表着过了一分钟，即腐烂感染一轮
            int size = queue.size();
            // rotten就是腐烂的橘子数量
            rotten += size;
            // 每一轮，即加一分钟
            minutes++;
            // 通过size，控制这一轮橘子
            while (size-- > 0) {
                // 取出这一轮橘子的位置
                int[] cur = queue.poll();
                int x = cur[0];
                int y = cur[1];
                for (int i = 0; i < 4; i++) {
                    int newX = x + dx[i];
                    int newY = y + dy[i];
                    // 将这一轮橘子的上下左右如果有好橘子，就变成坏橘子
                    if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == 1) {
                        grid[newX][newY] = 2;
                        // 并把新产生的坏橘子的位置加入队列中
                        queue.add(new int[]{newX, newY});
                    }
                }
            }
        }
        // 最终如果腐烂橘子数量等于全部橘子数量，即能全部感染，返回分钟数
        // Math.max(minutes, 0)是因为如果一开始就只有烂橘子，那就是0分钟
        return rotten == total ? Math.max(minutes, 0) : -1;
    }
}
```

### 207.课程表
``` java
class Solution {
    List<List<Integer>> edges;
    // 标记数组，0表示从未搜索到过，1表示搜索到过但还有前置课程，2表示已完成
    int[] visited;
    boolean valid = true;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // edges的下标对应课程的序号，课程0即edges中下标为0的元素
        edges = new ArrayList<>();
        for (int i = 0; i < numCourses; i++)
            edges.add(new ArrayList<>());
        visited = new int[numCourses];
        // 遍历prerequisites，将课程需要的前置课程加入edges相应的位置中
        for (int[] info : prerequisites)
            edges.get(info[1]).add(info[0]);
        // 深度优先搜索，从课程0开始
        for (int i = 0; i < numCourses && valid; i++)
            if (visited[i] == 0)
                dfs(i);
        return valid;
    }

    // 深度优先搜索
    public void dfs(int u) {
        // 将搜索过的课程标记为 1
        visited[u] = 1;
        // 检查该课程所需要的前置课程
        for (int v : edges.get(u)) {
            // 如果有前置课程还未被搜索到过，则加入dfs
            if (visited[v] == 0) {
                dfs(v);
                if (!valid)
                    return;
            } else if (visited[v] == 1) {
                valid = false;
                return;
            }
            // 如果有课程被搜索到过，说明这两节课相互依赖了，则不合法
        }
        // 如果这节课没有相互依赖，则标记为已完成
        visited[u] = 2;
    }
}
```

### 208.实现 Trie (前缀树)
``` java
class Trie {
    private Trie[] children;
    private boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
    
    // 本质就是一个 Trie 类，他有两个属性，一个 Trie 本身只记录一个字母
    // 一个是 Trie[] 数组，用来记录接下来的字母，比如如果 Trie[0] 不会null，表示有下一个字母 a
    // isEnd 表示从 第一个 Trie 开始，到现在这个 Trie，是否已经结尾
    public void insert(String word) {
        Trie node = this;
        for (int i = 0; i < word.length(); i++) {
            char ch = word.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null) {
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }

    private Trie searchPrefix(String prefix) {
        Trie node = this;
        for (int i = 0; i < prefix.length(); i++) {
            char ch = prefix.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null) {
                return null;
            }
            node = node.children[index];
        }
        return node;
    }
}
```

## 回溯
### 46.全排列
``` go
func permute(nums []int) [][]int {
    // res用来存储最终结果，path用来存储回溯中每一次符合条件的数组
    var res [][]int
    var path []int
    // used用来存储某一次回溯中已经使用过的元素，防止重复使用
    used := make([]bool, len(nums))
    
    // 回溯方法
    var backTrack func()
    backTrack = func() {
        // 如果path长度和原数组长度一致，则添加到最终结果res中
        if len(path) == len(nums) {
            // 将path复制到temp中，再加入到res
            // 因为如果 res = append(res, path) 会导致加入到res的是path的引用，之后修改path时，加入到res中的path也会跟着修改，导致最终res中全是相同的数组
            temp := make([]int, len(path))
            copy(temp, path)
            res = append(res, temp)
            return
        }
        for i := 0; i < len(nums); i++ {
            if used[i] {
                continue
            }
            path = append(path, nums[i])
            used[i] = true
            backTrack()
            // 回溯，一遍之后要把已经用过的改回没用过的状态
            used[i] = false
            path = path[:len(path)-1]
        }
    }
    
    backTrack()
    return res
}
```

### 78.子集
``` go
func subsets(nums []int) [][]int {
	var ans [][]int
	var path []int

    var backTrack func(startIndex int)

	backTrack = func(startIndex int) {
		tmp := make([]int, len(path))
        copy(tmp, path)
        ans = append(ans, tmp)

		if startIndex >= len(nums) {
			return
		}

		for i := startIndex; i < len(nums); i++ {
			path = append(path, nums[i])
			backTrack(i + 1)
			path = path[:len(path)-1]
		}
	}

	backTrack(0)
	return ans
}
```

### 17.电话号码的字母组合
``` java
class Solution {
    private List<String> ans = new ArrayList<>();
    private StringBuilder path = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) {
            return ans;
        }
        // 将电话号码对应的字符串转化为数组，方便使用
        String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
        backTrack(digits, numString, 0);
        return ans;
    }

    private void backTrack(String digits, String[] numString, int strLen) {
        // strLen为path的长度，如果长度等于需要求的字符串长度，则添加到ans中
        if (strLen == digits.length()) {
            ans.add(path.toString());
            return;
        }
        // 获取这一次回溯对应的字符串数组里的数组
        String str = numString[digits.charAt(strLen) - '0'];
        for (int i = 0; i < str.length(); i++) {
            path.append(str.charAt(i));
            // 回溯，将path长度加一，以及对应使用的字符串数组往后使用另一个
            backTrack(digits, numString, strLen + 1);
            // 回溯完需要删除最后一个添加的，才能是回溯
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

### 39.组合总和
``` cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> path;
        dfs(ans, path, candidates, target, 0, 0);
        return ans;
    }

    void dfs(vector<vector<int>>& ans, vector<int>& path, vector<int>& candidates, int target, int sum, int idx) {
        // 如果当前和等于目标值，则添加到ans中
        if (sum == target) {
            ans.push_back(path);
            return;
        }

        // 如果当前和已经大于目标值，直接返回
        if (sum > target)
            return; 

        // 常规回溯
        for (int i = idx; i < candidates.size(); i++) {
            path.push_back(candidates[i]);
            // 不一样的是，因为 同一个数字可以无限制重复被选取 ，所有每次递归的时候，idx 直接传递 i，而不需要传递 i + 1
            dfs(ans, path, candidates, target, sum + candidates[i], i);
            // 回溯删去最后一位
            path.pop_back();
        }
    }
};
```

### 22.括号生成
``` java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<>();
        backTrack(ans, new StringBuilder(), n, 0, 0);
        return ans;
    }

    void backTrack(List<String> ans, StringBuilder path, int n, int left, int right) {
        // left表示左括号个数，right表示右括号个数，两者都等于n，表明已经生成n对括号
        if (left == n && right == n)
            ans.add(path.toString());
        // 如果出现 左括号个数 小于 右括号个数，说明目前组合不合法，直接返回
        if (left < right)
            return;
        if (left < n) {
            // 只要左括号个数小于n，就可以一直添加
            path.append('(');
            // 然后回溯，将left加一
            backTrack(ans, path, n, left + 1, right);
            // 最后剪枝，删除最后一位
            path.deleteCharAt(path.length() - 1);
        }
        if (left > right) {
            // 只要右括号个数小于左括号个数，就可以一直添加
            path.append(')');
            // 然后回溯，将right加一
            backTrack(ans, path, n, left, right + 1);
            // 最后剪枝，删除最后一位
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

### 79.单词搜索
``` java
class Solution {
    // 上、下、左、右
    int[] dx = new int[] { -1, 0, 1, 0 };
    int[] dy = new int[] { 0, 1, 0, -1 };

    public boolean exist(char[][] board, String word) {
        // 回溯，遍历二维数组，从每个结点开始往四处扩展
        for (int i = 0; i < board.length; i++)
            for (int j = 0; j < board[0].length; j++)
                if (dfs(board, word, 0, i, j))
                    return true;
        return false;
    }

    // idx 表示这是这次回溯的第一个字母
    boolean dfs(char[][] board, String word, int idx, int x, int y) {
        // 如果和 word 相应下标对应的字母不同，直接返回错误
        if (board[x][y] != word.charAt(idx))
            return false;
        // 只要长度相同就说明字符串相同了
        if (idx == word.length() - 1)
            return true;
        // 先记录下这次遍历的元素，方便之后回溯
        char c = board[x][y];
        // 将这次遍历的元素变为点，标记为这次回溯已经遍历过这个位置了
        board[x][y] = '.';
        // 然后从这个节点往四个方向扩展，依次检查是否与字符串对应
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 0 || nx >= board.length || ny < 0 || ny >= board[0].length)
                continue;
            if (dfs(board, word, idx + 1, nx, ny))
                return true;
        }
        // 回溯，将之前改为点的元素变回
        board[x][y] = c;
        return false;
    }
}
```

### 131.分割回文串
``` java
class Solution {
    List<List<String>> ans = new ArrayList<>();
    List<String> path = new ArrayList<>();

    public List<List<String>> partition(String s) {
        backTrack(s, 0);
        return ans;
    }

    void backTrack(String s, int start) {
        if (start >= s.length()) {
            // 这里如果写成 ans.add(path) ，就会往 ans 里加入 path 的引用，后续修改 path，ans 里已经添加的 path 也会跟着修改
            ans.add(new ArrayList<>(path));
            return;
        }
        // 回溯中每个元素不可重复使用的情况下，一般就是从 start 开始，而不是从 0 开始
        for (int i = start; i < s.length(); i++) {
            if (check(s, start, i)) {
                String str = s.substring(start, i + 1);
                path.add(str);
            } else {
                continue;
            }
            backTrack(s, i + 1);
            path.removeLast();
        }
    }

    // 检查是否回文
    boolean check(String s, int start, int end) {
        while (start < end) {
            if (s.charAt(start) != s.charAt(end))
                return false;
            start++;
            end--;
        }
        return true; 
    }
}
```

### 51.N 皇后
``` java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
        // 先创建棋盘，所有位置全部放入点
        char[][] chessboard = new char[n][n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                chessboard[i][j] = '.';
        dfs(n, 0, ans, chessboard);
        return ans;
    }

    void dfs(int n, int row, List<List<String>> ans, char[][] chessboard) {
        // 最后一行遍历完，则加入到答案中
        if (row == n) {
            List<String> path = new ArrayList<>();
            for (char[] str : chessboard) {
                path.add(new String(str));
            }
            ans.add(new ArrayList<>(path));
            return;
        }
        // 回溯
        for (int col = 0; col < n; col++) {
            if (check(n, row, col, chessboard)) {
                chessboard[row][col] = 'Q';
                dfs(n, row + 1, ans, chessboard);
                chessboard[row][col] = '.';
            }
        }
    }

    boolean check(int n, int row, int col, char[][] chessboard) {
        // 检查竖着的同一列中有没有皇后
        for (int i = 0; i < row; i++)
            if (chessboard[i][col] == 'Q')
                return false;

        // 检查从该点到左上方，斜着的一排有没有皇后 (45度对角线)
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
            if (chessboard[i][j] == 'Q')
                return false;

        // 检查该点到右上方，斜着的一排有没有皇后 (135度对角线)
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)
            if (chessboard[i][j] == 'Q')
                return false;

        return true;
    }
}
```

## 二分查找
### 35.搜索插入位置
``` java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int n = nums.length;
        int left = 0, right = n - 1;
        // 左右二分查找
        while (left <= right) {
            // 计算左右指针中间值
            int mid = left + (right - left) / 2;
            // 如果中间值 大于等于 target，则将右指针移动到中间值左侧
            if (nums[mid] >= target) {
                right = mid - 1;
            }
            // 反之，将左指针移动到中间值右侧
            else {
                left = mid + 1;
            }
        }
        // 这里其实，比如数组为 [1, 3, 5, 6]
        // 如果 target = 5，则 left = 5，right = 3
        // 如果 target = 4，则 left = 5，right = 3
        return left
    }
}
```

### 74.搜索二维矩阵
``` java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // 先对第一列用二分查找
        int col = binarySearchColumn(matrix, target);
        if (col == -1) {
            return false;
        }
        // 在对刚刚求出的行用二分查找
        return binarySearchRow(matrix[col], target);
    }

    private int binarySearchColumn(int[][] matrix, int target) {
        int low = 0, high = matrix.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            // 如果求 **小于或等于目标值的最大索引** , 则用 mid <= target
            // 如果求 **大于或等于目标值的最小索引** , 则用 mid >= target
            if (matrix[mid][0] <= target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return high;
    }

    private boolean binarySearchRow(int[] row, int target) {
        int left = 0, right = row.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (row[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return row[right] == target;
    }
}
``` 

### 34.在排序数组中查找元素的第一个和最后一个位置
``` java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length;
        int left = 0, right = n - 1;

        if (n == 0)
            return new int[]{-1, -1};

        // 二分查找，因为用的是 mid >= target , 所以 left 就是 大于或等于目标值的最小索引
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) 
                right = mid - 1;
            else
                left = mid + 1;
        } 

        // 判断 nums[left] 是否等于 target
        if (left >= n || nums[left] != target) 
            return new int[]{-1, -1};

        // 如果是，就一直往后，直到不等于 target
        for (int i = left; i < n; i++) 
            if (nums[i] != target) 
                return new int[]{left, i - 1};

        return new int[]{left, n - 1};   
    }
}
``` 

### 33.搜索旋转排序数组
``` go
func search(nums []int, target int) int {
    n := len(nums)
    L, R := 0, n - 1
    for L <= R {
        // 虽然整体不是有序的，但是分成两半，一定至少有一半是有序的
        mid := L + (R - L) / 2
        if nums[mid] == target {
            return mid
        }
        // 0 到 mid 部分是有序的
        if nums[0] <= nums[mid] {
            // target 在 0 到 mid 这一部分
            // 因为 0 到 mid 这一部分是有序的，所以接下来就是正常的二分查找
            if nums[0] <= target && target < nums[mid] {
                R = mid - 1
            // target 在 mid 到 n - 1 这一部分
            // 因为 mid 到 n - 1 这一部分不一定是有序的，所以再在这的一部分切割，直到 target 处于有序的一部分
            } else {
                L = mid + 1
            }
        } else {
            // 与上面的情况正好相反
            if nums[mid] < target && target <= nums[n - 1] {
                L = mid + 1;
            } else {
                R = mid - 1;
            }
        }
    }
    return -1;
}
```

### 153.寻找旋转排序数组中的最小值
``` go
func findMin(nums []int) int {
    n := len(nums)
    L, R := 0, n - 1
    // 假设数组的最后一个元素是 x , 那在最小值右边的元素一定都小于 x , 在最小值左边的元素一定都大于 x
    for L < R {
        pivot := L + (R - L) / 2
        // 如果中间值大于右边界，说明中间值在最小值的左边，可以把范围更新到[中间值 + 1,右边界]
        if nums[pivot] >= nums[R] {
            L = pivot + 1
        // 反之更新[左边界, 中间值]
        } else {
            R = pivot
        }
    }
    return nums[L]
}
```

### 4.寻找两个正序数组的中位数
``` java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
         * 这里的 "/" 表示整除
         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
         * 这样 pivot 本身最大也只能是第 k-1 小的元素
         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
         */

        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            // 边界情况
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }
            
            // 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }
    }
}

```

## 栈
### 20.有效的括号
``` java
class Solution {
    public boolean isValid(String s) {
        int n = s.length();
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '(') {
                stack.push(')');
            } 
            else if (s.charAt(i) == '[') {
                stack.push(']');
            }
            else if (s.charAt(i) == '{') {
                stack.push('}');
            }
            else if (stack.isEmpty() || stack.peek() != s.charAt(i)) {
                return false;
            } 
            else {
                stack.pop();
            }
        }
        return stack.isEmpty();
    }
}
``` 

### 155.最小栈
``` java
class MinStack {
    // 两个栈，一个是正常栈，一个是辅助栈
    Deque<Integer> minStack;
    Deque<Integer> supStack;

    public MinStack() {
        minStack = new LinkedList<Integer>();
        supStack = new LinkedList<Integer>();
        supStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int val) {
        // 正常栈就是普通推入推出
        minStack.push(val);
        // 辅助栈就是推入的时候，如果比栈顶元素小，就正常推入，不然就推入和栈顶元素一样的一个复制
        supStack.push(Math.min(val, supStack.peek()));
    }
    
    public void pop() {
        minStack.pop();
        supStack.pop();
    }
    
    public int top() {
        return minStack.peek();
    }
    
    public int getMin() {
        return supStack.peek();
    }
}
```

### 394.字符串解码
``` java
class Solution {
    int ptr;

    public String decodeString(String s) {
        LinkedList<String> stk = new LinkedList<String>();
        ptr = 0;

        while (ptr < s.length()) {
            char cur = s.charAt(ptr);
            if (Character.isDigit(cur)) {
                // 获取一个数字并进栈
                String digits = getDigits(s);
                stk.addLast(digits);
            } else if (Character.isLetter(cur) || cur == '[') {
                // 获取一个字母并进栈
                stk.addLast(String.valueOf(s.charAt(ptr++))); 
            } else {
                ++ptr;
                // 辅助栈
                LinkedList<String> sub = new LinkedList<String>();
                // else情况其实就是ptr指向 ']' 情况
                // 此时将 栈stack 中直到最近的一个 '[' 之间所有的元素都推出，加入到 辅助栈sub 中
                while (!"[".equals(stk.peekLast())) {
                    sub.addLast(stk.removeLast());
                }
                // 因为从 栈stack 到 辅助栈sub 中所有元素会反着，所以还要翻转一下
                Collections.reverse(sub);
                // 左括号出栈
                stk.removeLast();
                // 此时栈顶为当前 sub 对应的字符串应该出现的次数
                int repTime = Integer.parseInt(stk.removeLast());
                StringBuffer t = new StringBuffer();
                String o = getString(sub);
                // 构造字符串
                while (repTime-- > 0) {
                    t.append(o);
                }
                // 将构造好的字符串入栈
                stk.addLast(t.toString());
            }
        }

        return getString(stk);
    }

    // 只要指针指着的是数字，就加入 ret 中，指针后移，如果后移后还是数字，继续加入
    // 就是返回一个连着的数字
    public String getDigits(String s) {
        StringBuffer ret = new StringBuffer();
        while (Character.isDigit(s.charAt(ptr))) {
            ret.append(s.charAt(ptr++));
        }
        return ret.toString();
    }

    // 返回整个栈中所有的字符串
    public String getString(LinkedList<String> v) {
        StringBuffer ret = new StringBuffer();
        for (String s : v) {
            ret.append(s);
        }
        return ret.toString();
    }
}
```

### 739.每日温度
``` java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] ans = new int[n];
        // 栈用来存下标，方便计算天数
        Deque<Integer> stk = new LinkedList<>();

        for (int i = 0; i < n; i++)
            ans[i] = 0;

        for (int i = 0; i < n; i++) {
            // 遍历数组，如果遇到当前元素大于栈顶元素，则不停弹出栈顶元素，并计算天数加入ans中
            while (!stk.isEmpty() && temperatures[stk.peek()] < temperatures[i]) {
                ans[stk.peek()] = i - stk.peek();
                stk.pop();
            }
            stk.push(i);
        }

        return ans;
    }
}
```

### 84.柱状图中最大的矩形
``` java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        // left[i] 表示在 i 左边比 i 小的第一个元素
        int[] left = new int[n];
        // left[i] 表示在 i 右边比 i 小的第一个元素
        int[] right = new int[n];
        int ans = 0;
        Deque<Integer> stk = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            // 一直弹出到栈顶元素比 i 小
            while (!stk.isEmpty() && heights[stk.peek()] >= heights[i]) 
                stk.pop();
            left[i] = (stk.isEmpty() ? -1 : stk.peek());
            stk.push(i);
        }

        stk.clear();

        for (int i = n - 1; i >= 0; i--) {
            while (!stk.isEmpty() && heights[stk.peek()] >= heights[i]) 
                stk.pop();
            right[i] = (stk.isEmpty() ? n : stk.peek());
            stk.push(i);
        }

        for (int i = 0; i < n; i++) 
            // right[i] - left[i] 即 i 处高度为 heights[i] 时的最大宽度
            ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]);

        return ans;
    }
}
``` 

## 堆
### 215.数组中的第K个最大元素
``` java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 优先队列，主要难在优先队列如何自己手动构建
        PriorityQueue<Integer> maxHeep = new PriorityQueue<>(Comparator.reverseOrder());
        for (int num : nums) {
            maxHeep.offer(num);
        }
        for (int i = 0; i < k - 1; ++i) {
            maxHeep.poll();
        }
        return maxHeep.poll();
    }
}
``` 
> **手动构建优先队列（大根堆）方法**
``` java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeap(nums, heapSize);
        for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
            swap(nums, 0, i);
            heapSize--;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }

    void buildMaxHeap(int[] a, int heapSize) {
        for (int i = heapSize / 2 - 1; i >= 0; i--) {
            maxHeapify(a, i, heapSize);
        }
    }

    void maxHeapify(int[] a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        }
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a, i, largest);
            maxHeapify(a, largest, heapSize);
        }
    }

    void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
``` 

### 347.前 K 个高频元素
``` java
class Solution {
    // 本地使用小顶堆而不使用大顶堆的原因：
    // 小顶堆是总共维护 k 个元素，如果有元素比堆中最小的元素大，则移除堆中最小的元素（堆顶元素），加入该元素，所以时间复杂度则为 log (N logk)
    // 大顶堆则因为堆顶元素是最大元素，如果新进来一个元素，无法提前和堆中最小元素比较，且难以移除最小元素，导致要实现目标必须在堆中加入全部的元素，这样总共就必须维护 N 个元素，时间复杂度就变为 log（N logN）了
    public int[] topKFrequent(int[] nums, int k) {
        // lambda 表达式设置优先级队列从大到小存储 o1 - o2 （小顶堆）为从小到大，o2 - o1 （大顶堆）反之
        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
        int[] res = new int[k]; // 答案数组为 k 个元素
        Map<Integer, Integer> map = new HashMap<>(); // 记录元素出现次数
        for (int num : nums)
            map.put(num, map.getOrDefault(num, 0) + 1);
        for (var x : map.entrySet()) { // entrySet 获取 k-v Set 集合
            // 将 kv 转化成数组
            int[] tmp = new int[2];
            tmp[0] = x.getKey();
            tmp[1] = x.getValue();
            pq.offer(tmp);
            // 下面的代码是根据小根堆实现的，我只保留优先队列的最后的k个，只要超出了k我就将最小的弹出，剩余的k个就是答案
            if (pq.size() > k) {
                pq.poll();
            }
        }
        for (int i = 0; i < k; i++) {
            res[i] = pq.poll()[0]; // 获取优先队列里的元素
        }
        return res;
    }
}
```

### 295.数据流的中位数
``` java
class MedianFinder {
    Queue<Integer> queMax;
    Queue<Integer> queMin;

    public MedianFinder() {
        // 维护两个优先队列
        // queMax从小到大排序，出栈口为最小元素
        queMax = new PriorityQueue<>((a, b) -> a - b);
        // queMin从大到小排序，出站口为最大元素
        queMin = new PriorityQueue<>((a, b) -> b - a);
    }
    
    public void addNum(int num) {
        // 控制两个栈的数量，queMin 中元素的数量保证比 queMax 多一个或一样多
        if (queMin.isEmpty() || num <= queMin.peek()) {
            queMin.offer(num);
            if (queMin.size() > queMax.size() + 1) {
                queMax.offer(queMin.poll());
            }
        } else {
            queMax.offer(num);
            if (queMax.size() > queMin.size()) {
                queMin.offer(queMax.poll());
            }
        }
    }
    
    public double findMedian() {
        if (queMin.size() > queMax.size()) {
            return queMin.peek();
        } 
        return (queMin.peek() + queMax.peek()) / 2.0;
    }
}
```

## 贪心算法
### 121.买卖股票的最佳时机
``` java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        // dp数组含义: dp[i][0] 表示在第 0 到 i 间的某一天买入股票情况下，收益的最大值（即买最便宜的股票）
        //            dp[i][1] 表示在第 0 到 i 间的某一天卖出股票情况下，收益的最大值（即在股票最贵的时候卖出）
        int[][] dp = new int[n][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; i++) {
            // 比较是在 0 到 i - 1 中某一天买入的股票便宜，还是在第 i 天买入的股票便宜
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            // 比较是在 0 到 i - 1 中某一天股票价格最高，还是第 i 天股票价格最高
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[n - 1][1];
    }
}
``` 

### 55.跳跃游戏
``` go
func canJump(nums []int) bool {
	var cover int
	n := len(nums)
    for i := 0; i <= cover; i++ {
        // 就是不停推进最远可以跳到的范围
		cover = max(cover, i + nums[i])
        // 如果范围能覆盖到末尾处，则成功
		if cover >= n - 1 {
			return true
		}
	} 
    // 如果跳不到末尾处，则失败
	return false;
}
``` 

### 45.跳跃游戏 II
``` java
class Solution {
    public int jump(int[] nums) {
        if (nums.length == 1) 
            return 0;
        // 记录跳跃的次数
        int steps = 0;
        // 当前可达的最远距离，即不更新 steps，就从第一步开始能达的最远距离
        int curDistance = 0;
        // 最远可达距离，相当于你从目前可达的最远距离内，再挑选一个 i + nums[i] 最大的，即最远可达距离
        int maxDistance = 0;
        for (int i = 0; i < nums.length; i++) {
            // 不断更新最远可达距离
            maxDistance = Math.max(maxDistance, i + nums[i]);
            // 说明当前一步，再跳一步就到达了末尾
            if (maxDistance >= nums.length - 1) {
                steps++;
                break;
            }
            // 只有把目前可达的最远距离全部走完了，才更新 steps，即跳跃一次
            // 相当于遍历目前可达的最远距离内，挑选一个 i + nums[i] 最大的，再跳跃
            if (i == curDistance) {
                curDistance = maxDistance;
                steps++;
            }
        }
        return steps;
    }
}
```

### 763.划分字母区间
``` java
class Solution {
    public List<Integer> partitionLabels(String s) {
        int n = s.length();
        List<Integer> ans = new ArrayList<>();
        int[] last = new int[26];
        // 记录每个字母出现的最后位置的下标
        for (int i = 0; i < n; i++) 
            last[s.charAt(i) - 'a'] = i;
        
        int start = 0, end = 0;
        for (int i = 0; i < n; i++) {
            // i 不断往后遍历，然后 end 就是 s[0] 到 s[i] 中，字母出现最后位置中下标最大的，即最后面的
            end = Math.max(end, last[s.charAt(i) - 'a']);
            // 如果 i 追上了 end，就说明这个片段每个字母不会在接下来出线了
            if (i == end) {
                // 加入到 ans 中
                ans.add(i - start + 1);
                // 更新片段初始位置
                start = i + 1;
                end = 0;
            }
        }
        // 如果最后起始位置没有更新到数组最后，说明还有一个多出来的片段，直接加入到 ans 中
        if (start != n) 
            ans.add(n - start + 1);

        return ans;
    }
}
```

## 动态规划
### 70.爬楼梯
``` java
class Solution {
    // 斐波那契数列
    public int climbStairs(int n) {
        if (n <= 1)
            return n;
        // dp数字含义：dp[i]表示爬到 i - 1 层一共有多少种方法
        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < n; i++) 
            // 爬到 i 层，要么是从 i - 2 层两步爬上来，要么是从 i - 1 层一步爬上来
            dp[i] = dp[i - 2] + dp[i - 1];
        return dp[n - 1];
    }
}
```

### 118.杨辉三角
``` java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans = new ArrayList<>();
        // 遍历numRows，第 i 次遍历代表杨辉三角第 i + 1 行
        for (int i = 0; i < numRows; i++) {
            List<Integer> path = new ArrayList<>();
            for (int j = 0; j <= i; j++) {
                // 杨辉三角每一行第一个和最后一个都是 1
                if (j == 0 || j == i) {
                    path.add(1);
                } else {
                    path.add(ans.get(i - 1).get(j - 1) + ans.get(i - 1).get(j));
                }
            }
            ans.add(path);
        }
        return ans;
    }
}
```

### 198.打家劫舍
``` java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        // dp数组含义：dp[i][0] 表示第 i 天不偷情况下，偷窃的最大金额
        //            dp[i][1] 表示第 i 天偷的情况下，偷窃的最大金额（这一天偷就表示前一天不能偷）
        int[][] dp = new int[n][2];

        dp[0][0] = 0;
        dp[0][1] = nums[0];

        for (int i = 1; i < n; ++i) {
            // 这天不偷，即继承前一天 偷或不偷 中赚钱最多的一种
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
            // 这天如果偷，即前一天只能是不偷的情况
            dp[i][1] = dp[i - 1][0] + nums[i];
        }

        // 取最后一天偷或不偷的最大值
        return Math.max(dp[n - 1][0], dp[n - 1][1]);
    }
}
```

### 279.完全平方数
``` java
class Solution {
    public int numSquares(int n) {
        // dp数组含义：dp[i] 表示 数字i 最少有几个完全平方数组成
        int[] dp = new int[n + 1];
        for (int i = 1; i < n + 1; i++)
            dp[i] = Integer.MAX_VALUE - 1;
        dp[0] = 0;
        // i 相当于是物品（即平方数），表示使用从 1的平方 到 i的平方 里所有平方数
        for (int i = 0; i * i < n + 1; i++) {
            // j表示背包容量
            for (int j = i * i; j < n + 1; j++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
```

### 322.零钱兑换
``` python
class Solution:
    # 本地与上题 279.完全平方数 基本一样
    def coinChange(self, coins: List[int], amount: int) -> int:
        # dp数组含义：dp[i] 表示 凑成 总金额 i 所需的最少硬币个数
        dp = [sys.maxsize - 1] * (amount + 1)
        dp[0] = 0

        # i 相当于硬币的种类，表示使用从 coins[0] 到 coins[i] 中所有种类的硬币
        for i in range(len(coins)):
            # j 表示背包容量
            for j in range(coins[i], amount + 1):
                dp[j] = min(dp[j], dp[j - coins[i]] + 1)

        return -1 if dp[amount] == sys.maxsize - 1 else dp[amount]

```

### 139.单词拆分
``` java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>(wordDict);
        // dp数组含义：dp[i] 表示 从 s.charAt(0) 到 s.charAt(i - 1) 所有字符都能在wordDict中找到
        boolean[] dp = new boolean[s.length() + 1];

        dp[0] = true;
        for (int i = 1; i < s.length() + 1; i++)
            dp[i] = false;
        
        // 遍历，截取字符串 j 到 i - 1，查找set中有没有，有则 dp[i] 标记为true
        for (int i = 1; i < s.length() + 1; i++) 
            // && !dp[i] 是用于在 dp[i] 标记为 true 后，跳过本次 j 循环
            for (int j = 0; j < i && !dp[i]; j++) 
                // && dp[j] 意思是，只有 0 到 j - 1 都有，才有继续判断的必要
                if (set.contains(s.substring(j, i)) && dp[j])
                    dp[i] = true;
            
        return dp[s.length()];
    }
}
```

### 300.最长递增子序列
``` go
func lengthOfLIS(nums []int) int {
    n := len(nums)
    // dp数组含义：dp[i] 表示 数组从 0 到 i 里最长递增子序列长度
    dp := make([]int, n)
    ans := 1

    for i := range dp {
        dp[i] = 1
    }

    for i := 1; i < n; i++ {
        for j := 0; j < i; j++ {
            // 其实就是找到 nums[i] 左边最靠近 nums[i] 但比 nums[i] 小的元素的递增子序列长度加上一
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j] + 1)
            }
        }
        ans = max(ans, dp[i])
    }

    return ans
}
```

### 152.乘积最大子数组
``` go
func maxProduct(nums []int) int {
    ans, maxVal, minVal := nums[0], nums[0], nums[0]
    for i := 1; i < len(nums); i++ {
        // 之所以还要算 curMin，是因为如果 curMin 是负数，nums[i] 也是负数，相乘可能大于 curMax
        curMax, curMin := maxVal * nums[i], minVal * nums[i]
        // 然后就是不断比较一直相乘大，还是新的 nums[i] 大
        maxVal = max(max(curMax, curMin), nums[i])
        minVal = min(min(curMax, curMin), nums[i])
        // ans 取最大值
        ans = max(ans, maxVal)
    }
    return ans
}
```

### 416.分割等和子集
``` java
class Solution {
    public boolean canPartition(int[] nums) {
        // 计算整个数组和
        int sum = 0;
        for (int num : nums) sum += num;
        // 如果数组和是技术，则肯定不能被平分
        if (sum % 2 != 0) return false;
        // 将问题转换成 01背包问题
        // 数组每个元素大小，即是价值，也是重量
        // 因为重量和价值相等，所以装满背包target重量情况下，理论最大价值也是target
        int target = sum / 2;
        // dp数组含义：dp[i] 表示 装满背包容量i 物品的最大价值
        int dp[] = new int[target + 1];
        // 外层循环i遍历物品种类
        for (int i = 0; i < nums.length; i++) 
            // 内层循环j遍历背包容量
            // 遍历的目标不是全部，而是那些能装得下 nums[i] 的容量
            // 算出 dp[j - nums[i]] + nums[i]
            // 其实是 dp[j - weight[i]] + value[i]
            for (int j = target; j >= nums[i]; j--) 
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
    // 因为重量价值相等，所以能装满背包target价值最大理论就是target，所以如果dp[target] == target，即能平分
        return dp[target] == target;
    }
}
```

### 32.最长有效括号
``` go
func longestValidParentheses(s string) int {
	n := len(s)
    // dp数组含义：到 i 为止，最长的括号字串长度
	dp := make([]int, n)
    ans := 0
    // 遍历所有括号
	for i := 1; i < n; i++ {
        // 只有遍历到 ')' 时做出反应
		if s[i] == ')' {
            // 如果前一个就是 '(' ，则取 i - 2 位置的长度再加上 2
			if s[i - 1] == '(' {
				if i >= 2 {
					dp[i] = dp[i - 2] + 2
				} else {
					dp[i] = 2
				}
            // 如果是 "...))" 的形式，则查看前一个括号字串再前面一位是不是 '(' 
			} else if i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(' {
                // 是就加上该 '(' 的再再前面的括号字串长度，加上中间括号字串长度再加上 2
                if i - dp[i - 1] - 2 > 0 {
				    dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2
                } else {
                    dp[i] = dp[i - 1] + 2
                }
			}
        ans = max(ans, dp[i])
		}
	}
    return ans;
}
```

## 多维动态规划
### 62.不同路径
``` java
class Solution {
    public int uniquePaths(int m, int n) {
        // dp数组含义：dp[i][j] 表示 起点 到 网格(i, j) 共有多少条路径
        int[][] dp = new int[m][n];

        for (int i = 0; i < m; i++) 
            dp[i][0] = 1;

        for (int i = 0; i < n; i++) 
            dp[0][i] = 1;    

        for (int i = 1; i < m; i++)
            for (int j = 1; j < n; j++)
                // 到 网格(i, j) 只有 从网格(i - 1, j)往右走一格 或 从网格(i, j - 1)往下走一格 两种情况
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

        return dp[m - 1][n - 1];
    }
}
```

### 64.最小路径和
``` java
class Solution {
    public int minPathSum(int[][] grid) {
        int row = grid.length, col = grid[0].length;
        // dp数组含义：dp[i][j] 表示 起点 到 网格(i, j) 路径上的最小数字总和
        int[][] dp = new int[row][col];
        dp[0][0] = grid[0][0];

        for (int i = 1; i < row; i++) 
            dp[i][0] = grid[i][0] + dp[i - 1][0];

        for (int j = 1; j < col; j++)
            dp[0][j] = grid[0][j] + dp[0][j - 1];

        // 因为只能向下或者向右，所以比较从哪边来数字总和最小
        for (int i = 1; i < row; i++) 
            for (int j = 1; j < col; j++) 
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            
        return dp[row - 1][col - 1];
    }
}
```

### 5.最长回文子串
``` java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        // dp数组含义：dp[i][j]表示 从 dp[i] 到 dp[j] 组成回文子串
        boolean[][] dp = new boolean[n][n];
        int maxLen = 1, begin = 0;

        // 单独一个字母肯定是回文子串
        for (int i = 0; i < n; i++)
            dp[i][i] = true;

        // 通过枚举长度，类似滑动窗口，然后用这个窗口遍历字符串，进行校验
        for (int size = 2; size <= n; size++) 
            for (int i = 0; i < n - size + 1; i++) {
                // j - i + 1 就是当前枚举的长度
                int j = i + size - 1;
                // 如果最边缘两个都不一样，肯定不是回文子串
                if (s.charAt(i) != s.charAt(j))
                    dp[i][j] = false;   
                else {
                    // 如果边缘两个相等，并且枚举长度小于等于三个，那就是回文子串
                    if (size <= 3) 
                        dp[i][j] = true;
                    else {
                        // 枚举长度大于三个时，如果边缘两个相等，那是否构成回文子串，就看两边各往中心缩小一位，看是否回文子串，因为长度是从小到大枚举的
                        dp[i][j] = dp[i + 1][j - 1]; 
                    }
                }
                // 如果当前枚举长度构成回文子串，记录最大长度
                if (dp[i][j] && size > maxLen) {
                    maxLen = size;
                    begin = i;
                }
            }
        
        return s.substring(begin, begin + maxLen);
    }
}
```

### 1143.最长公共子序列
``` java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n1 = text1.length() + 1, n2 = text2.length() + 1;
        // dp数组含义：dp[i][j] 表示text1从0到i为止，text2从0到j为止，最长公共子序列
        int[][] dp = new int[n1][n2];
        for (int i = 1; i < n1; i++)
            for (int j = 1; j < n2; j++) {
                // 想象一个二维数组
                // 如果遍历到的两个字符相同，最长公共子序列就是 i，j 左上角那个 i - 1，j - 1 再加上一
                if (text1.charAt(i - 1) == text2.charAt(j - 1))
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                // 如果不相同，就比较上边的（i - 1，j）和左边的（i，j - 1）哪个大
                else 
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        return dp[n1 - 1][n2 - 1];
    }
}
```

### 72.编辑距离
``` java
class Solution {
    public int minDistance(String word1, String word2) {
        int n1 = word1.length() + 1, n2 = word2.length() + 1;
        // dp数组含义: dp[i][j] 表示 word1到i，word2到j为止 两者修改到相同最小步骤
        int[][] D = new int[n1][n2];
        // 初始化dp数组，因为从 0 修改到长度为 i 的字符串，步骤就是 i
        for (int i = 0; i < n1; i++) D[i][0] = i;
        for (int i = 0; i < n2; i++) D[0][i] = i;
        for (int i = 1; i < n1; i++) {
            for (int j = 1; j < n2; j++) {
                // 如果遍历到的两个字母相同，那就是 i - 1 和 j - 1 位需要修改的次数，因为相当于多出来两个相同的字母，不用修改
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) D[i][j] = D[i - 1][j - 1];
                // 如果不同，就比较 三种情况最小值 再加上 1
                else D[i][j] = min(D[i - 1][j], D[i][j - 1], D[i - 1][j - 1]) + 1;
            }
        }
        return D[n1 - 1][n2 - 1];
    }

    private int min(int x, int y, int z) {
        return Math.min(x, Math.min(y, z));
    }
}
```

## 技巧
### 136.只出现一次的数字
``` java
class Solution {
    public int singleNumber(int[] nums) {
        int single = 0;
        for (int num : nums) {
            // 位运算
            // 任何数和0做异或运算，结果仍然是原来的数，即a⊕0=a
            // 任何数和其自身做异或运算，结果是0，即a⊕a=0
            // 异或运算满足交换律和结合律，即a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b
            // 所以，比如数组nums为[1, 1, 2, 3, 3]
            // 1^1^2^3^3 = (1^1) ^ (3^3) ^ 2 = 0^0^2 = 2
            single ^= num;
        }
        return single;
    }
}
```

### 169.多数元素
``` cpp
// 投票算法
// nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
// candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
// count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
// 当 count == 0 时，candidate 就变为 nums[i] 
// 接下来如果 candidate 不等于 nums[i]，count 就减少 1，直到变为 0，candidate 选择新的数字，即重新选举众数
// 最后 candidate 就是众数
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int count = 0, candidate = -1;
        for (int num : nums) {
            if (count == 0) candidate = num;
            if (candidate == num) count++;
            else count--;
        }
        return candidate;
    }
};
```

### 75.颜色分类
``` go
func sortColors(nums []int)  {
    n := len(nums)
    p0, p1 := 0, 0
    // 双指针，p0 用来移动 0，p1 用来移动 1，i 用来遍历
    for i := 0; i < n; i++ {
        // 遇到 1 就和 p1 交换，p1后移
        if nums[i] == 1 {
            nums[i], nums[p1] = nums[p1], nums[i]
            p1++
        // 遇到 0 就和 p0 交换，p0 和 p1 都后移，因为 0 一定排在 1 前面
        } else if nums[i] == 0 {
            nums[i], nums[p0] = nums[p0], nums[i]
            // 如果 p1 在 p0 前面，说明 p0 其实指着 1，前面 p0 把 0 交换过来了，原本的 1 到后面去了，所以也要交换回来
            if p0 < p1 {
                nums[i], nums[p1] = nums[p1], nums[i]
            }
            p0++
            p1++
        }
    }
}
```

### 31.下一个排列
``` java
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        // 从数组末尾开始，寻找第一个非倒序排序的元素，记录下标 i
        // 如 [1,2,4,3] ，因为 2 4 是升序排序，所以 i 就记录为 1
        int i = n - 2;
        while (i >= 0 && num s[i] >= nums[i + 1])
            i--;
        // 从末尾开始，寻找第一个不小于 nums[i] 的元素
        //  如 [1,2,4,3] ，nums[i] 是 2，则第一个便是 3，即下标为3的元素
        if (i >= 0) {
            int j = n - 1;
            while (j >= 0 && nums[j] <= nums[i])
                j--;
            // 交换 nums[i] 和 nums[j]
            // 即从 [1,2,4,3] 变为 [1,3,4,2]
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
        // 然后翻转 从下标 i 到 n - 1 的所有元素
        // 即 [1,3,4,2] 变为 [1,3,2,4]
        reverseArray(nums, i + 1);
    }

    // 从下标 i 开始，到数组末尾，全部翻转
    public void reverseArray(int[] arr, int i) {
        int left = i, right = arr.length - 1;
        while (left < right) {
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
}
```

### 287.寻找重复数
``` java
class Solution {
    public int findDuplicate(int[] nums) {
        // 快慢指针 
        int slow = 0, fast = 0;
        // 将nums数组想象成从 i 到 nums[i] 的环形链表
        // value 6 2 1 5 5 3 4
        // index 0 1 2 3 4 5 6
        // 6 -> 4 -> 5(i:4) -> 3(环起点) -> 5(i:3) -> 3 -> 5(i:3)
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        slow = 0;
        // 找到环的起点，其下标 i 即重复数，参考题142
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
}
```
