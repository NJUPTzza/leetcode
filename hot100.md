# hot100
## 哈希
### 1.两数之和
``` java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(target - nums[i])) {
                return new int[] { map.get(target - nums[i]), i };
            }
            map.put(nums[i], i);
        }
        return new int[0];
    }
}
```

### 49.字母异位词分组
``` java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // 用排序好的字符串作为map的key值，value就是各种排序
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs) {
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            // 这里不能用 chars.toString() ，不然返回的是对象的类名加哈希码（内存地址的某种表示形式）。
            String key = new String(chars);
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            map.put(key, list);
        }
        // map.values() 返回的就是一个数组，map的每个value就是数组的一个元素
        return new ArrayList<>(map.values());
    }
}
```

### 128.最长连续序列
``` java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        int cur = 0, maxLen = 0, ans = 0;
        // 讲数组中所有元素放入Set中
        for (int num : nums) {
            set.add(num);
        }
        for (int i : set) {
            // 检测是否是连续序列的第一个值（最小值），如果是就重新开始计数
            if (!set.contains(i - 1)) {
                cur = i;
                maxLen = 1;
            }
            // 如果是连续序列的最小值，则开始往下计数
            while (set.contains(cur + 1)) {
                maxLen++;
                cur++;
            }
            ans = Math.max(maxLen, ans);
        }
        return ans;
    }
}
```

## 双指针
### 283.移动零
``` java
class Solution {
    public void moveZeroes(int[] nums) {
        // 快慢指针
        int slow = 0, fast = 0;
        while (fast < nums.length) {
            if (nums[fast] != 0) {
                nums[slow++] = nums[fast];
            }
            fast++;
        }
        while (slow < nums.length) {
            nums[slow++] = 0;
        }
    }
}
```

### 11.盛最多水的容器
``` java
class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int left = 0, right = n - 1;
        int ans = 0;
        while (left < right) {
            int w = right - left;
            int h = Math.min(height[left], height[right]);
            int area = w * h;
            ans = Math.max(ans, area);
            // 如果左边数较小则左指针移动，右边数较小就右指针移动
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return ans;
    }
}
```

### 15.三数之和
``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        // 枚举 i
        for (int i = 0; i < n; i++) {
            // 如果 i 与上次重复，就直接省略，减少重复
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int k = n - 1;
            // 利用 j + k = -i 来寻找符合条件的 j 和 k
            int target = -nums[i];
            // 枚举 j
            for (int j = i + 1; j < n; j++) {
                // 如果 j 与上次重复，就直接省略，减少重复
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                // 保证 j 在 k 左边的同时不断将 k 左移，枚举 k
                while (j < k && nums[j] + nums[k] > target) {
                    k--;
                }
                // 如果 j 与 k 重叠，则说明这个 i 情况已经枚举完毕
                if (j == k) {
                    break;
                }
                // 如果等于，则加入ans中
                if (nums[j] + nums[k] == target) {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[k]);
                    ans.add(list);
                }
            }
        }
        return ans;
    }
}
```

### 42.接雨水
``` java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        // 左右指针
        int left = 0, right = n - 1;
        // 记录左边开始的最高柱子，和右边开始的最高柱子
        int leftMax = 0, rightMax = 0;
        int ans = 0;
        while (left < right) {
            // 如果左指针指的柱子更矮
            if (height[left] < height[right]) {
                // 更新左边开始的最高柱子
                leftMax = Math.max(leftMax, height[left]);
                // height[left]处能接的雨水则为 左边开始的最高柱子 和 当前左指针指的柱子 的高度差，即 leftMax - height[left] 
                ans += leftMax - height[left];
                // 移动左指针
                left++;
            } else {
                rightMax = Math.max(rightMax, height[right]);
                ans += rightMax - height[right];
                right--;
            }
        }
        return ans;
    }
}
```

## 滑动窗口
### 3.无重复字符的最长子串
``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // Set集合用来判断是否重复
        Set<Character> occ = new HashSet<>();
        int n = s.length();
        int ans = 0;
        // rk为滑动窗口的右边界
        int rk = -1;
        for (int i = 0; i < n; i++) {
            // 每次循环相当于滑动窗口左边界向右移动一格
            if (i != 0) {
                occ.remove(s.charAt(i - 1));
            }
            // rk在每次循环中不用重新 = -1，因为上一次循环 i 到 rk 无重复值，这一次 i + 1 到 rk 肯定也没有重复值
            while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {
                occ.add(s.charAt(rk + 1));
                rk++;
            }
            ans = Math.max(ans, rk - i + 1);
        }
        return ans;
    }
}
```

### 3.找到字符串中所有字母异位词
``` java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int sLen = s.length(), pLen = p.length();
        List<Integer> ans = new ArrayList<>();
        // 如果s长度小于p长度，则字符串s不可能包含p
        if (sLen < pLen) {
            return ans;
        }
        // 定义一个长度为pLen的滑动窗口，用数组记录这个窗口内每个字母的数量，再以字符串p内包含字母对比，来确定是否是字母异位词
        int[] sArr = new int[26];
        int[] pArr = new int[26];
        for (int i = 0; i < pLen; i++) {
            sArr[s.charAt(i) - 'a']++;
            pArr[p.charAt(i) - 'a']++;
        }
        // 用于判断滑动窗口初始位置是不是字母异位词
        if (Arrays.equals(sArr, pArr)) {
            ans.add(0);
        }
        for (int i = 0; i < sLen - pLen; i++) {
            // 不断将滑动窗口右移
            sArr[s.charAt(i) - 'a']--;
            sArr[s.charAt(i + pLen) - 'a']++;
            if (Arrays.equals(sArr, pArr)) {
                ans.add(i + 1);
            }
        }
        return ans;
    }
}
```

## 子串
### 560.和为K的子数组
``` java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int ans = 0;
        // 利用pre和一个哈希表来实现前缀和的效果
        int pre = 0; 
        Map<Integer, Integer> mp = new HashMap<>();
        // pre就相当于nums数组从0到i所有数字之和，利用之前哈希表做的做成的前缀和表，实现 pre - 某前缀和 = k 这个式子的变形，来判断子串和为k
        mp.put(0, 1);
        for (int i = 0; i < n; i++) {
            pre += nums[i];
            // 哈希表存放的是数组到i为止所有的前缀和，以及出现的次数，如果哈希表存在 pre - k ，即子串和为k
            if (mp.containsKey(pre - k)) {
                ans += mp.get(pre - k);
            }
            mp.put(pre, mp.getOrDefault(pre, 0) + 1);
        }
        return ans;
    }
}
```

### 239.滑动窗口最大值
``` java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        // 用队列来实现滑动窗口
        Deque<Integer> deque = new LinkedList<>();
        // 滑动窗口中存放数组下标，利用 deque.peekFirst() <= i - k 这个特性可以实现提前删去不可能的值并且实现单调队列
        for (int i = 0; i < k; i++) {
            // 第一个滑动窗口，如果 nums[i] <= nums[j] 并且 i < j 则 i 可以直接删去，保证滑动窗口第一个就是该滑动窗口最大值
            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
                deque.pollLast();
            }
            deque.offerLast(i);
        }
        ans[0] = nums[deque.peekFirst()];
        for (int i = k; i < n; i++) {
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            deque.offerLast(i);
            // 如果当前滑动窗口第一个已经超出滑动窗口范围，则删去
            if (deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            ans[i - k + 1] = nums[deque.peekFirst()];
        }
        return ans;
    }
}
```

### 76.最小覆盖子串
``` java
class Solution {
    // 用哈希表存储某段字符串中每个字母的数量
    Map<Character, Integer> tMap = new HashMap<>();
    // 用来储存滑动窗口中有与 t字符串 中相同的字母
    Map<Character, Integer> sMap = new HashMap<>();

    public String minWindow(String s, String t) {
        int tLen = t.length();
        int sLen = s.length();
        // 用 字符串t 里的各字母数量做哈希表，用来对比是否是子串
        for (int i = 0; i < tLen; i++) {
            char c = t.charAt(i);
            tMap.put(c, tMap.getOrDefault(c, 0) + 1);
        }
        int l = 0, r = -1;
        // len是用来记录目前位置的最小长度
        int len = Integer.MAX_VALUE;
        int ansL = -1, ansR = -1;
        while (r < sLen) {
            // 每次循环将滑动窗口右边界右移
            r++;
            // 如果右边界扩充到的字母在 字符串t 中有，则添加到 sMap 中
            if (r < sLen && tMap.containsKey(s.charAt(r))) {
                sMap.put(s.charAt(r), sMap.getOrDefault(s.charAt(r), 0) + 1);
            }
            // 如果滑动窗口已经包含 字符串t 中全部字母，并且滑动窗口左边界还没越过有边界
            while (check() && l <= r) {
                // 如果 当前长度 小于 最小长度
                if (r - l + 1 < len) {
                    // 更新最小长度，并将答案左边界有边界更新
                    len = r - l + 1;
                    ansL = l;
                    ansR = l + len;
                }
                // 将滑动窗口左边界向左移动，并移除左边界的字母
                if (tMap.containsKey(s.charAt(l))) {
                    sMap.put(s.charAt(l), sMap.getOrDefault(s.charAt(l), 0) - 1);
                }
                l++;
            }
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR);
    }

    // 检查方法，用迭代器遍历哈希表，用来检查 sMap 是否已经包含 tMap 中的所有字母
    private boolean check() {
        Iterator iter = tMap.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            Character key = (Character) entry.getKey();
            Integer val = (Integer) entry.getValue();
            if (sMap.getOrDefault(key, 0) < val) {
                return false;
            }
        }
        return true;
    }
}
```

## 普通数组
### 53.最大子数组和\
``` java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int ans = nums[0];
        // dp数组含义：dp[i]表示从0到i最大子数组和
        int[] dp = new int[n];
        dp[0] = nums[0];
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```

### 56.合并区间
``` java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 先根据数组第一位数字进行排序
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        int n = intervals.length;
        List<int[]> ans = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            // 如果前一个区间完全在后一个区间的前面没有重叠，如 [1][3] 到 [5][6] 
            if (intervals[i - 1][1] < intervals[i][0]) {
                ans.add(intervals[i - 1]);
            } else {
                // 如果有重叠，如 [1][3] 到 [2][6]，前一个范围第二位 3 比 后一个范围第一位 2 要大，所以将后一个范围第一位改为较大的 3
                intervals[i][0] = intervals[i - 1][0];
                // 后一个范围第二位则取两个范围第二位中的较大值
                intervals[i][1] = Math.max(intervals[i - 1][1], intervals[i][1]);
            }
        }
        // 因为一直加入ans中的是前一个范围，所以最后会剩下一个范围，也要加入ans
        ans.add(intervals[n - 1]);
        return ans.toArray(new int[ans.size()][]);
    }
}
```

### 189.轮转数组
``` go
func rotate(nums []int, k int) {
    n := len(nums)
    k = k % n  // 处理 k 大于数组长度的情况
    count := 0 // 记录已经替换的元素个数

    // 遍历数组，直到所有元素都被替换
    for start := 0; count < n; start++ {
        cur := start
        prev := nums[start] 

        // 环状替换
        for {
            next := (cur + k) % n // 计算下一个位置
            nums[next], prev = prev, nums[next] // 交换元素
            cur = next
            count++

            // 如果回到起点，结束当前环
            if cur == start {
                break
            }
        }
    }
}
```

### 238.除自身以外数组的乘积
``` java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        // 先遍历一遍，ans[i] 含义为 nums[0] * nums[1] * ... * nums[i - 1]
        ans[0] = 1;
        for (int i = 1; i < n; i++) {
            ans[i] = ans[i - 1] * nums[i - 1];
        }

        // 用一个 R 来代替 R[] 数组，R[i] 为 nums[n - 1] * nums[n] * ... * nums[i + 1]
        int R = 1;
        for (int i = n - 1; i >= 0; i--) {
            ans[i] *= R;
            // 不断更新R
            R *= nums[i];
        }
        return ans;
    }
}
```

## 矩阵
### 73.矩阵置零
``` java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        // 用标记数组，记录哪一行哪一列有0
        boolean[] row = new boolean[m];
        boolean[] col = new boolean[n];

        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (matrix[i][j] == 0)
                    row[i] = col[j] = true;

        // 再根据标记数组，来把有0的行列都变为0
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (row[i] || col[j])
                    matrix[i][j] = 0;
    }
}
``` 

## 链表
### 160.相交链表
``` java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // Set集合用来记录某一条链表上的所有结点
        Set<ListNode> set = new HashSet<>();
        ListNode node = headA;
        // 将A链表上所有结点加入Set中
        while (node != null) {
            set.add(node);
            node = node.next;
        }
        node = headB;
        // 遍历B链表，如果有结点存在于Set集合中，说明两链表相交
        while (node != null) {
            if (set.contains(node)) {
                return node;
            }
            node = node.next;
        }
        return null;
    }
}
```

### 206.反转链表
``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        // 定义两个指针，前指针指向头节点前一个，后指针指向头节点
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            // 新定义一个指针，指向后指针的下一个
            ListNode next = cur.next;
            // 将 后指针的下一个 从往后改为往前
            cur.next = pre;
            // 将 前指针指向的 改为 后指针指向 的
            pre = cur;
            // 将 后指针 往后移
            cur = next;
        } 
        return pre;
    }
}
```

### 234.回文链表
``` java
class Solution {
    ListNode frontPointer;

    public boolean isPalindrome(ListNode head) {
        frontPointer = head;
        return recurse(head);
    }

    // 通过递归方法检查是否回文
    private boolean recurse(ListNode curPointer) {
        if (curPointer != null) {
            // 通过递归一直将cur指针后移到最后一个结点
            if (!recurse(curPointer.next)) {
                return false;
            }
            // 比较cur指针和front指针结点的值是否一致，即前后是否一致
            if (curPointer.val != frontPointer.val) {
                return false;
            }
            // 将前指针向后移动
            frontPointer = frontPointer.next;
        }
        // 通过递归，将后指针前移   
        return true;
    }
}
``` 

### 141.环形链表
``` java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false; // 链表为空或只有一个节点，无环
        }
        ListNode slow = head;
        ListNode fast = head;
        // 快慢指针遍历
        while (fast != null && fast.next != null) {
            slow = slow.next; // 慢指针走一步
            fast = fast.next.next; // 快指针走两步
            // 如果快慢指针相遇，说明有环
            if (slow == fast) {
                return true;
            }
        }
        return false; // 无环
    }
}
``` 

### 142.环形链表 II
``` java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null; // 链表为空或只有一个节点，无环
        }
        ListNode slow = head;
        ListNode fast = head;
        // 快慢指针遍历
        while (fast != null && fast.next != null) {
            slow = slow.next;          // 慢指针走一步
            fast = fast.next.next;      // 快指针走两步
            // 如果快慢指针相遇，说明有环
            if (slow == fast) {
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null; // 无环
    }
}
```

### 108.将有序数组转换为二叉搜索树
``` java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return traversal(nums, 0, nums.length - 1);
    }

    TreeNode traversal(int[] nums, int left, int right) {
        if (left > right)
            return null;
        int mid = left + (right - left) / 2;
        // 因为是有序数组，所以数组的中间数就是二叉搜索树的根节点
        TreeNode node = new TreeNode(nums[mid]);
        // 然后数组中间数左边的就继续构成根节点左子树
        node.left = traversal(nums, left, mid - 1);
        // 数组中间数右边的就构成根节点右子树
        node.right = traversal(nums, mid + 1, right);
        return node;
    }
}
```

### 21.合并两个有序链表
``` java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 虚拟头节点，用来保存头节点的地址，后续方便return
        ListNode dummyHead = new ListNode(-1);
        // 遍历链表的指针
        ListNode ptr = dummyHead;
        // 将 list1 和 list2 按大小接到 新链表的后边，直到有一个链表全部遍历完
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                ptr.next = list1;
                list1 = list1.next;
            } else {
                ptr.next = list2;
                list2 = list2.next;
            }
            ptr = ptr.next;
        }
        // 将另一个没遍历完的链表，整个直接接到新链表后面
        ptr.next = list1 == null ? list2 : list1;
        return dummyHead.next;
    }
}
```

## 二叉树
### 94.二叉树的中序遍历
``` java
class Solution {
    List<Integer> ans;

    public List<Integer> inorderTraversal(TreeNode root) {
        ans = new ArrayList<Integer>();
        traversal(root);
        return ans;
    }

    // 递归遍历法
    void traversal(TreeNode node) {
        if (node == null) {
            return;
        }
        // 中序遍历，先左，再中，再右
        traversal(node.left);
        ans.add(node.val);
        traversal(node.right);
    }
}
```

### 104.二叉树的最大深度
``` java
class Solution {
    public int maxDepth(TreeNode root) {
        return traversal(root);
    }

    public int traversal(TreeNode node) {
        if (node == null) {
            return 0;
        }
        // 左树高度
        int leftHeight = traversal(node.left);
        // 右树高度
        int rightHeight = traversal(node.right);
        // 取较大者再加一，即目前结点的高度
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

### 226.翻转二叉树
``` java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        traversal(root);
        return root;
    }

    public void traversal(TreeNode pointer) {
        if (pointer == null) {
            return;
        }
        // 遍历整个二叉树，将每个结点的左右子树交换
        TreeNode tmp = pointer.left;
        pointer.left = pointer.right;
        pointer.right = tmp;
        traversal(pointer.left);
        traversal(pointer.right);
    }
}
```

### 101.对称二叉树
``` java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return compare(root.left, root.right);
    }

    // 左右对比
    public boolean compare(TreeNode left, TreeNode right) {
        // 如果左节点为空，右节点不为空，则不对称
        if (left == null && right != null)
            return false;
        // 如果左节点不为空，右节点为空，则不对称
        else if (left != null && right == null)
            return false;
        // 如果左右结点都为空，说明对称，并下面没有需要比较的内容了，终止递归
        else if (left == null && right == null)
            return true;
        // 如果左右结点 value 不一样，则不对称
        else if (left.val != right.val)
            return false;
        // 对比每个结点的外侧结点
        boolean compareOutside = compare(left.left, right.right);
        // 对比每个结点的内侧结点
        boolean compareInside = compare(left.right, right.left);
        // 如果外侧内测都相同，则返回相同
        return compareOutside && compareInside;
    }
}
``` 

### 543.二叉树的直径
``` java
 */
class Solution {
    private int diameter;

    public int diameterOfBinaryTree(TreeNode root) {
        getDepth(root);
        return diameter;
    }

    public int getDepth(TreeNode node) {
        if (node == null)
            return 0;
        // 获取左子树高度和右子树高度
        int leftDepth = getDepth(node.left);
        int rightDepth = getDepth(node.right);
        // 左右子树高度之和 即该树任意两个节点之间最长路径的长度（二叉树的直径）
        diameter = Math.max(diameter, leftDepth + rightDepth);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
``` 

### 102.二叉树的层序遍历
``` java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        // 先将第一层（即头结点）加入到队列中
        if (root != null)
            queue.add(root);
        while (!queue.isEmpty()) {
            // 记录该层的节点数
            int size = queue.size();
            List<Integer> path = new ArrayList<>();
            // 如果该层节点数归零，说明该层节点已经遍历完了，切换到下一层
            while (size > 0) {
                // 从左到右把每个节点从队列中拿出来
                TreeNode node = queue.poll();
                path.add(node.val);
                // 然后把该节点的左右子节点添加到队列中，作为下一层节点
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
                size--;
            }
            ans.add(path);
        }
        return ans;
    }
}
```

## 图论
### 200.岛屿数量
``` javascript
var numIslands = function (grid) {
    if (grid === null || grid.length === 0) {
        return 0;
    }

    let H = grid.length;
    let W = grid[0].length;
    let ans = 0;

    // 遍历整个grid，如果遇到 ‘1’，则调用 dfs 方法将 和该‘1’一座岛的‘1’全部变为‘0’
    for (let i = 0; i < H; i++) {
        for (let j = 0; j < W; j++) {
            if (grid[i][j] === '1') {
                ans++;
                dfs(i, j);
            }
        }
    }

    function dfs(h, w) {
        // ‘1’ 附近扩散至边界或者 ’0‘ 处停止
        if (h < 0 || h >= H || w < 0 || w >= W || grid[h][w] === '0') {
            return;
        }

        grid[h][w] = '0';
        // 向上下左右扩散
        dfs(h + 1, w);
        dfs(h - 1, w);
        dfs(h, w + 1);
        dfs(h, w - 1);
    };

    return ans;
};
```

## 回溯
### 46.全排列
``` go
func permute(nums []int) [][]int {
    // res用来存储最终结果，path用来存储回溯中每一次符合条件的数组
    var res [][]int
    var path []int
    // used用来存储某一次回溯中已经使用过的元素，防止重复使用
    used := make([]bool, len(nums))
    
    // 回溯方法
    var backTrack func()
    backTrack = func() {
        // 如果path长度和原数组长度一致，则添加到最终结果res中
        if len(path) == len(nums) {
            // 将path复制到temp中，再加入到res
            // 因为如果 res = append(res, path) 会导致加入到res的是path的引用，之后修改path时，加入到res中的path也会跟着修改，导致最终res中全是相同的数组
            temp := make([]int, len(path))
            copy(temp, path)
            res = append(res, temp)
            return
        }
        for i := 0; i < len(nums); i++ {
            if used[i] {
                continue
            }
            path = append(path, nums[i])
            used[i] = true
            backTrack()
            // 回溯，一遍之后要把已经用过的改回没用过的状态
            used[i] = false
            path = path[:len(path)-1]
        }
    }
    
    backTrack()
    return res
}
```

### 17.电话号码的字母组合
``` java
class Solution {
    private List<String> ans = new ArrayList<>();
    private StringBuilder path = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) {
            return ans;
        }
        // 将电话号码对应的字符串转化为数组，方便使用
        String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
        backTrack(digits, numString, 0);
        return ans;
    }

    private void backTrack(String digits, String[] numString, int strLen) {
        // strLen为path的长度，如果长度等于需要求的字符串长度，则添加到ans中
        if (strLen == digits.length()) {
            ans.add(path.toString());
            return;
        }
        // 获取这一次回溯对应的字符串数组里的数组
        String str = numString[digits.charAt(strLen) - '0'];
        for (int i = 0; i < str.length(); i++) {
            path.append(str.charAt(i));
            // 回溯，将path长度加一，以及对应使用的字符串数组往后使用另一个
            backTrack(digits, numString, strLen + 1);
            // 回溯完需要删除最后一个添加的，才能是回溯
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

### 78.子集
``` go
func subsets(nums []int) [][]int {
	var ans [][]int
	var path []int

    var backTrack func(startIndex int)

	backTrack = func(startIndex int) {
		tmp := make([]int, len(path))
        copy(tmp, path)
        ans = append(ans, tmp)

		if startIndex >= len(nums) {
			return
		}

		for i := startIndex; i < len(nums); i++ {
			path = append(path, nums[i])
			backTrack(i + 1)
			path = path[:len(path)-1]
		}
	}

	backTrack(0)
	return ans
}
```

### 39.组合总和
``` cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> path;
        dfs(ans, path, candidates, target, 0, 0);
        return ans;
    }

    void dfs(vector<vector<int>>& ans, vector<int>& path, vector<int>& candidates, int target, int sum, int idx) {
        // 如果当前和等于目标值，则添加到ans中
        if (sum == target) {
            ans.push_back(path);
            return;
        }

        // 如果当前和已经大于目标值，直接返回
        if (sum > target)
            return; 

        // 常规回溯
        for (int i = idx; i < candidates.size(); i++) {
            path.push_back(candidates[i]);
            // 不一样的是，因为 同一个数字可以无限制重复被选取 ，所有每次递归的时候，idx 直接传递 i，而不需要传递 i + 1
            dfs(ans, path, candidates, target, sum + candidates[i], i);
            // 回溯删去最后一位
            path.pop_back();
        }
    }
};
```

### 22.括号生成
``` java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<>();
        backTrack(ans, new StringBuilder(), n, 0, 0);
        return ans;
    }

    void backTrack(List<String> ans, StringBuilder path, int n, int left, int right) {
        // left表示左括号个数，right表示右括号个数，两者都等于n，表明已经生成n对括号
        if (left == n && right == n)
            ans.add(path.toString());
        // 如果出现 左括号个数 小于 右括号个数，说明目前组合不合法，直接返回
        if (left < right)
            return;
        if (left < n) {
            // 只要左括号个数小于n，就可以一直添加
            path.append('(');
            // 然后回溯，将left加一
            backTrack(ans, path, n, left + 1, right);
            // 最后剪枝，删除最后一位
            path.deleteCharAt(path.length() - 1);
        }
        if (left > right) {
            // 只要右括号个数小于左括号个数，就可以一直添加
            path.append(')');
            // 然后回溯，将right加一
            backTrack(ans, path, n, left, right + 1);
            // 最后剪枝，删除最后一位
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

## 二分查找
### 35.搜索插入位置
``` java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int n = nums.length;
        int left = 0, right = n - 1;
        // 左右二分查找
        while (left <= right) {
            // 计算左右指针中间值
            int mid = left + (right - left) / 2;
            // 如果中间值 大于等于 target，则将右指针移动到中间值左侧
            if (nums[mid] >= target) {
                right = mid - 1;
            }
            // 反之，将左指针移动到中间值右侧
            else {
                left = mid + 1;
            }
        }
        // 这里其实，比如数组为 [1, 3, 5, 6]
        // 如果 target = 5，则 left = 5，right = 3
        // 如果 target = 4，则 left = 5，right = 3
        return left
    }
}
```

### 74.搜索二维矩阵
``` java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // 先对第一列用二分查找
        int col = binarySearchColumn(matrix, target);
        if (col == -1) {
            return false;
        }
        // 在对刚刚求出的行用二分查找
        return binarySearchRow(matrix[col], target);
    }

    private int binarySearchColumn(int[][] matrix, int target) {
        int low = 0, high = matrix.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            // 如果求 **小于或等于目标值的最大索引** , 则用 mid <= target
            // 如果求 **大于或等于目标值的最小索引** , 则用 mid >= target
            if (matrix[mid][0] <= target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return high;
    }

    private boolean binarySearchRow(int[] row, int target) {
        int left = 0, right = row.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (row[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return row[right] == target;
    }
}
``` 

### 34.在排序数组中查找元素的第一个和最后一个位置
```  java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length;
        int left = 0, right = n - 1;

        if (n == 0)
            return new int[]{-1, -1};

        // 二分查找，因为用的是 mid >= target , 所以 left 就是 大于或等于目标值的最小索引
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) 
                right = mid - 1;
            else
                left = mid + 1;
        } 

        // 判断 nums[left] 是否等于 target
        if (left >= n || nums[left] != target) 
            return new int[]{-1, -1};

        // 如果是，就一直往后，直到不等于 target
        for (int i = left; i < n; i++) 
            if (nums[i] != target) 
                return new int[]{left, i - 1};

        return new int[]{left, n - 1};   
    }
}
``` 

## 栈
### 20.有效的括号
``` java
class Solution {
    public boolean isValid(String s) {
        int n = s.length();
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '(') {
                stack.push(')');
            } 
            else if (s.charAt(i) == '[') {
                stack.push(']');
            }
            else if (s.charAt(i) == '{') {
                stack.push('}');
            }
            else if (stack.isEmpty() || stack.peek() != s.charAt(i)) {
                return false;
            } 
            else {
                stack.pop();
            }
        }
        return stack.isEmpty();
    }
}
``` 

### 155.最小栈
``` java
class MinStack {
    // 两个栈，一个是正常栈，一个是辅助栈
    Deque<Integer> minStack;
    Deque<Integer> supStack;

    public MinStack() {
        minStack = new LinkedList<Integer>();
        supStack = new LinkedList<Integer>();
        supStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int val) {
        // 正常栈就是普通推入推出
        minStack.push(val);
        // 辅助栈就是推入的时候，如果比栈顶元素小，就正常推入，不然就推入和栈顶元素一样的一个复制
        supStack.push(Math.min(val, supStack.peek()));
    }
    
    public void pop() {
        minStack.pop();
        supStack.pop();
    }
    
    public int top() {
        return minStack.peek();
    }
    
    public int getMin() {
        return supStack.peek();
    }
}
```

## 堆
### 215.数组中的第K个最大元素
``` java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 优先队列，主要难在优先队列如何自己手动构建
        PriorityQueue<Integer> maxHeep = new PriorityQueue<>(Comparator.reverseOrder());
        for (int num : nums) {
            maxHeep.offer(num);
        }
        for (int i = 0; i < k - 1; ++i) {
            maxHeep.poll();
        }
        return maxHeep.poll();
    }
}
``` 
> **手动构建优先队列（大根堆）方法**
``` java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeap(nums, heapSize);
        for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
            swap(nums, 0, i);
            heapSize--;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }

    void buildMaxHeap(int[] a, int heapSize) {
        for (int i = heapSize / 2 - 1; i >= 0; i--) {
            maxHeapify(a, i, heapSize);
        }
    }

    void maxHeapify(int[] a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        }
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a, i, largest);
            maxHeapify(a, largest, heapSize);
        }
    }

    void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
``` 

## 贪心算法
### 121.买卖股票的最佳时机
``` java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        // dp数组含义: dp[i][0] 表示在第 0 到 i 间的某一天买入股票情况下，收益的最大值（即买最便宜的股票）
        //            dp[i][1] 表示在第 0 到 i 间的某一天卖出股票情况下，收益的最大值（即在股票最贵的时候卖出）
        int[][] dp = new int[n][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; i++) {
            // 比较是在 0 到 i - 1 中某一天买入的股票便宜，还是在第 i 天买入的股票便宜
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            // 比较是在 0 到 i - 1 中某一天股票价格最高，还是第 i 天股票价格最高
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[n - 1][1];
    }
}
``` 

### 55.跳跃游戏
``` go
func canJump(nums []int) bool {
	var cover int
	n := len(nums)
    for i := 0; i <= cover; i++ {
        // 就是不停推进最远可以跳到的范围
		cover = max(cover, i + nums[i])
        // 如果范围能覆盖到末尾处，则成功
		if cover >= n - 1 {
			return true
		}
	} 
    // 如果跳不到末尾处，则失败
	return false;
}
``` 

## 动态规划
### 70.爬楼梯
``` java
class Solution {
    // 斐波那契数列
    public int climbStairs(int n) {
        if (n <= 1)
            return n;
        // dp数字含义：dp[i]表示爬到 i - 1 层一共有多少种方法
        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < n; i++) 
            // 爬到 i 层，要么是从 i - 2 层两步爬上来，要么是从 i - 1 层一步爬上来
            dp[i] = dp[i - 2] + dp[i - 1];
        return dp[n - 1];
    }
}
```

### 118.杨辉三角
``` java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans = new ArrayList<>();
        // 遍历numRows，第 i 次遍历代表杨辉三角第 i + 1 行
        for (int i = 0; i < numRows; i++) {
            List<Integer> path = new ArrayList<>();
            for (int j = 0; j <= i; j++) {
                // 杨辉三角每一行第一个和最后一个都是 1
                if (j == 0 || j == i) {
                    path.add(1);
                } else {
                    path.add(ans.get(i - 1).get(j - 1) + ans.get(i - 1).get(j));
                }
            }
            ans.add(path);
        }
        return ans;
    }
}
```

### 198.打家劫舍
``` java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        // dp数组含义：dp[i][0] 表示第 i 天不偷情况下，偷窃的最大金额
        //            dp[i][1] 表示第 i 天偷的情况下，偷窃的最大金额（这一天偷就表示前一天不能偷）
        int[][] dp = new int[n][2];

        dp[0][0] = 0;
        dp[0][1] = nums[0];

        for (int i = 1; i < n; ++i) {
            // 这天不偷，即继承前一天 偷或不偷 中赚钱最多的一种
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
            // 这天如果偷，即前一天只能是不偷的情况
            dp[i][1] = dp[i - 1][0] + nums[i];
        }

        // 取最后一天偷或不偷的最大值
        return Math.max(dp[n - 1][0], dp[n - 1][1]);
    }
}
```

### 279.完全平方数
``` java
class Solution {
    public int numSquares(int n) {
        // dp数组含义：dp[i] 表示 数字i 最少有几个完全平方数组成
        int[] dp = new int[n + 1];
        for (int i = 1; i < n + 1; i++)
            dp[i] = Integer.MAX_VALUE - 1;
        dp[0] = 0;
        // i 相当于是物品（即平方数），表示使用从 1的平方 到 i的平方 里所有平方数
        for (int i = 0; i * i < n + 1; i++) {
            // j表示背包容量
            for (int j = i * i; j < n + 1; j++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
```

### 322.零钱兑换
``` python
class Solution:
    # 本地与上题 279.完全平方数 基本一样
    def coinChange(self, coins: List[int], amount: int) -> int:
        # dp数组含义：dp[i] 表示 凑成 总金额 i 所需的最少硬币个数
        dp = [sys.maxsize - 1] * (amount + 1)
        dp[0] = 0

        # i 相当于硬币的种类，表示使用从 coins[0] 到 coins[i] 中所有种类的硬币
        for i in range(len(coins)):
            # j 表示背包容量
            for j in range(coins[i], amount + 1):
                dp[j] = min(dp[j], dp[j - coins[i]] + 1)

        return -1 if dp[amount] == sys.maxsize - 1 else dp[amount]

```

## 多维动态规划
### 62.不同路径
``` java
class Solution {
    public int uniquePaths(int m, int n) {
        // dp数组含义：dp[i][j] 表示 起点 到 网格(i, j) 共有多少条路径
        int[][] dp = new int[m][n];

        for (int i = 0; i < m; i++) 
            dp[i][0] = 1;

        for (int i = 0; i < n; i++) 
            dp[0][i] = 1;    

        for (int i = 1; i < m; i++)
            for (int j = 1; j < n; j++)
                // 到 网格(i, j) 只有 从网格(i - 1, j)往右走一格 或 从网格(i, j - 1)往下走一格 两种情况
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

        return dp[m - 1][n - 1];
    }
}
```

## 技巧