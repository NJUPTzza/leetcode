# 面试
## 自我介绍
面试官您好，我叫钟泽安，来自南京邮电大学计算机科学与技术专业。自大一入学，我跟着学长接触前后端开发。第一学期后，我加入了校级开发团队青柚工作室，专注于 Java 后端开发。期间，我参与维护面向全校师生的南邮小程序，还参与开发了小程序微信支付服务（之前是只有E卡通支付选项的）、单点登录鉴权服务（年报和对内），以及年报项目，积累了丰富的项目经验 。

## 项目介绍
### PAY
- 小程序端
    - 前端向服务器发送体育场地预订请求。服务器接收到请求后，使用 Redisson 的 rLock 加锁，此锁优势显著，实现逻辑简单，且若线程长时间未完成操作，锁会自动释放，避免死锁，保障系统稳定性。

    - 服务器在获取锁后，修改数据库中场地的状态为 “已预订”。接着，按照支付系统的规则生成签名，将包含订单信息与签名的数据发送给支付系统。

- 支付服务
    - 订单生成：支付服务接收到请求后，生成初始状态（init）的订单。利用雪花算法生成全局唯一的订单 ID，同时对订单内的各项信息进行严格检查，如订单金额、商品详情、用户信息等。检查无误后，将订单信息存入数据库，并把订单初始状态（init）和订单详情加入到 Redis 的 rStream 中，以便后续相关服务订阅处理。

    - 收银处理：前端将用户选择的支付方式和订单信息发送至后端。后端再次校验签名确保数据未被篡改，之后使用分布式锁（如 Redisson 的 rLock）锁定该订单。在更新订单状态前，检查订单当前状态是否符合操作要求，若状态正常则将订单状态更新为 “支付中”（paying）。根据用户选择的支付方式，从预设的策略中挑选合适的支付策略。完成操作后，更新数据库中的订单信息，并释放分布式锁。最后，将更新后的订单状态（paying）和订单详情加入到 rStream 中。

    - 支付信息生成与处理：根据支付策略生成相应的支付信息（如支付链接、二维码等），发送给前端供用户跳转支付。同时，将订单加入到 Redis 的 rDelayedQueue 中，设置支付超时时间，若超时未支付，后续进行相应处理（如取消订单、释放场地）。

    - 支付结果处理：支付系统通过异步通知（NotifyUrl）告知支付服务支付结果。支付服务检查支付是否完成，若完成则将订单状态更新为 “已支付”（paid），并将更新后的订单状态和订单详情加入到 rStream 中，以便其他业务系统获取最新状态进行后续处理。
### SSO
- OAuth2
    > 关于授权的开放网络标准，允许用户用第三方应用的授权信息登录还不需要将账号和密码提供给第三方应用
    授权码模式：用户访问客户端，客户端把用户导向授权服务器，授权服务器问用户是否给客户端授权，用户同意后，授权服务器将用户导向客户端的重定向URL并附上授权码，client_id客户端ID需要在授权服务器上注册，response_type返回授权码，scope权限范围，rediect_uri重定向uri用于授权成功后跳转。客户端拿到授权码后，向授权服务器申请令牌，授权服务器核对授权码，向客户端发送访问令牌和更新令牌，客户端通过访问令牌请求资源服务器，资源服务器通过相同的加密解密校验

- RBAC-ACL
    > 用户表，角色表，权限表，用户角色表，角色权限表
    ACL表：订单号，用户，请求操作，权限验证

面试官您好，下面我来更详细地介绍一下这个项目：
这个项目主要融合了 SSO、OAuth2 以及 RBAC - ACL 这几种技术。
SSO 也就是单点登录，主要作用是让用户在访问多个相关系统时，只需要登录一次，不用在每个系统都重复输入用户名和密码，大大提升了用户体验。
OAuth2 则是一种授权框架，在我们这个项目里，它和 SSO 配合得很紧密。用户在 SSO 系统登录成功后，SSO 会借助 OAuth2 的机制生成一个令牌，其他系统通过验证这个令牌来确认用户身份，这样就实现了用户在不同系统间的无缝访问。
RBAC - ACL 是关于权限管理的部分。RBAC 是基于角色的访问控制，我们会根据用户在组织中的角色来分配权限，比如管理员角色可能有创建、删除用户等所有权限，普通用户角色就只有查看和修改个人信息等基本权限。ACL 是访问控制列表，它能针对具体的资源进行更细致的权限设置，像某个数据库表，可能管理员有读写权限，普通用户只有读权限。
总的来说，这个项目通过 SSO 和 OAuth2 实现了方便快捷的单点登录功能，又通过 RBAC - ACL 实现了精准、灵活的权限管理，让整个系统在保证安全性的同时，也能给用户提供很好的使用体验，提高了工作效率，也降低了管理成本。

> EventLoop机制，异步非阻塞IO，简单高效处理大量并发，提高吞吐量，
轻量，占用内存小
多模块通信，登录成功，访问权限模块获取权限

## 技术栈问题
- Netty
> Netty 基于 Reactor 模型构建，采用事件驱动机制高效处理网络通信。它有 BossGroup 和 WorkerGroup 两个线程组，BossGroup 线程组负责接收客户端的连接请求，将其注册到 Selector 上，随后把连接分配给 WorkerGroup 线程组。WorkerGroup 线程组有多个NioEventLoop，每个 NioEventLoop 都关联一个 Selector，网络连接 Channel 会注册到 NioEventLoop 的 Selector 上，Selector 就可以监控多个 Channel 的 I/O 事件状态。Channel 对应的 ChannelPipeline 可以绑定多个 Handler 组成的 Handler 链，数据在其中依次传递，各 Handler 按自身逻辑处理，让 Netty 能灵活实现复杂业务，达成高性能网络通信。  

- Vertx
> Vert.x 是一个用于在 JVM 上构建响应式应用程序的工具包。它基于事件驱动和非阻塞 I/O 模型，具备多语言支持的特性。Vert.x 有事件循环（Event Loop）机制，负责处理异步事件。当客户端发起请求时，事件循环接收并分发事件。其 Verticle 类似于轻量级进程，可部署多个实例以实现并行处理。数据在不同的 Verticle 之间通过消息总线进行传递，消息总线支持多种消息传递模式，如点对点、发布 - 订阅等。这种架构使得 Vert.x 能够高效地处理大量并发请求，灵活构建各类分布式系统和微服务应用。

> Verticle是vertx应用的基本构建单元，类似轻量级别的线程，每个Verticle负责执行特定的任务，EventBus分布式消息传递机制，无论其他服务的vertx实例还是同一个中的其他Verticle都可以通过EventBus进行消息发送和接受。EventLoop会不断轮训注册的IO操作，比如创建HTTP服务器会把接受的客户端连接注册到EventLoop上，一个vertx实例可以有好几个EventLoop，一个EventLoop里可以有好几个Verticle，消息发送和接受其实是EventLoop做的。
一个EventLoop是单线程的，执行异步任务

- RabbitMQ
> RabbitMQ 是一个开源的消息代理软件，基于 AMQP（高级消息队列协议）构建。它采用生产者 - 消费者模型，生产者将消息发布到交换器（Exchange），交换器根据预设的路由规则将消息路由到对应的队列（Queue）。消费者从队列中获取消息进行处理。RabbitMQ 有多种交换器类型，如直连交换器、主题交换器、扇形交换器等，以满足不同的消息路由需求。同时，它支持消息持久化、事务处理、集群和镜像队列等特性，保障了消息传递的可靠性和高可用性，广泛应用于分布式系统中的异步通信和解耦场景。

- Elasticsearch
> Elasticsearch 是一个分布式、RESTful 风格的搜索和分析引擎，基于 Lucene 构建。它将数据以文档形式存储在索引中，索引可进行分片和副本设置。分片允许数据分散存储在多个节点上，提高了系统的可扩展性和并发处理能力；副本则增强了数据的可靠性。当用户发起搜索请求时，请求会被分发到各个相关分片上进行并行搜索，然后将结果汇总返回。Elasticsearch 支持多种查询方式，如全文搜索、结构化搜索、地理空间搜索等，还能进行实时数据分析和可视化，广泛应用于日志分析、内容搜索、商业智能等领域。

- OAuth2
> OAuth2 是一种开放标准的授权协议，用于在不暴露用户密码的情况下，允许第三方应用访问用户在资源服务器上的受限资源。它涉及四个角色：资源所有者（通常是用户）、客户端（第三方应用）、授权服务器和资源服务器。授权流程一般包括客户端向授权服务器请求授权码，用户同意授权后，客户端使用授权码向授权服务器换取访问令牌，最后客户端使用访问令牌向资源服务器请求资源。OAuth2 定义了多种授权类型，如授权码模式、隐式模式、密码模式和客户端凭证模式，以适应不同的应用场景，保障了用户数据的安全性和授权的灵活性。

- RBAC
> RBAC（基于角色的访问控制）是一种广泛应用的访问控制模型，它通过角色来管理用户对系统资源的访问权限。在 RBAC 中，用户被分配到不同的角色，每个角色具有特定的权限集合。系统管理员通过定义角色和权限的对应关系，以及用户和角色的分配关系来实现访问控制。当用户尝试访问系统资源时，系统会根据用户所属的角色来判断其是否具有相应的访问权限。这种模型简化了权限管理，提高了系统的可维护性和安全性，适用于各种规模和复杂度的系统。

- 设计模式
> 单例模式：一个对象只有一个实例
工厂模式：多个类实现一个接口，再在工厂类里判断实例化哪个类
抽象工厂：一个抽象工厂决定实例化哪个工厂
策略模式：多个类实现一个策略接口，然后某一个类注入这个策略接口，这个类实例化的时候要选择具体是哪个实现这个策略接口的类

- 微服务架构
> 网关：身份验证，限流，熔断等
注册中心：管理各个服务的地址和端口，服务启动时会把自己的信息注册到注册中心
配置中心：集中管理微服务的配置信息，如某个服务的数据库配置等
分布式事务：跨服务操作全部完成或不完成
rpc：RPC 允许程序在不同的服务器或计算机之间进行通信，就好像在本地调用函数一样。