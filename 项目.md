# 项目
## PAY
### 简单流程
- booking in pomelo pay
    - 前端传过来用户信息、时间段、体育场馆
    - 上锁
    - 检查场地是否已经被占用
    - 将订单初始化信息存入数据库

- sign order in pomelo pay
    - 从数据库找到自己的初始化订单
    - 生成订单签名，发送到pay

- 初始化
    - 验证金额格式，第三方服务，第三方签名校验
    - 创建Order对象，OpenID第三方用户唯一标识，NotifyUrl异步通知地址

- create
    - 雪花算法生成订单id
    - 设置order.status为init

- publish
    - 将订单和状态加入到rStream中

- create
    - Span设置跟踪标签，订单id和状态

- cashier
    - 验证签名
    - Span设置跟踪标签，订单id和状态
    - redission分布式锁获取订单
    - 检查订单状态
    - 更新order.status为paying
    - 根据用户选择的支付方式选择相应的支付策略

- publish
    - 将订单和状态加入到rStream中

- cashier
    - 构建校园一卡通收银参数
    - 将订单加入rDelayedQueue

- pay
    - 拿到订单
    - 经订单结果异步通知

### 复杂流程
项目整体流程
1. 前端请求预订（booking in pomelo pay）
前端数据收集与发送
前端页面提供用户信息（如姓名、学号、联系方式等）、时间段选择器和体育场馆列表。用户在界面上输入或选择相应信息后，前端对输入的数据进行初步的格式验证，例如检查时间段是否合理、用户信息是否完整等。
若验证通过，前端将这些信息封装成一个请求对象，通过 HTTP 请求发送到后端接口。
后端处理
上锁：后端接收到请求后，使用 Redisson 分布式锁机制，根据用户选择的时间段和体育场馆生成一个唯一的锁键，例如 venue_booking:{stadium_id}:{start_time}-{end_time}，尝试获取该锁。如果在一定时间内（如 5 秒）未能获取到锁，说明该时间段和场馆可能正在被其他用户操作，返回错误信息给前端，提示用户稍后重试。
检查场地是否已被占用：获取到锁后，查询数据库中该时间段和体育场馆的预订记录。若存在有效的预订记录，则说明场地已被占用，释放锁并返回错误信息给前端，告知用户该场地在所选时间段已被预订。
订单初始化信息存入数据库：若场地未被占用，创建一个初始的订单对象，将用户信息、时间段、体育场馆等信息存储在订单对象中。同时，设置订单的初始状态为 INIT（初始化），记录订单的创建时间。将该订单对象插入到数据库的订单表中，并生成一个唯一的订单 ID（可使用雪花算法，后续步骤会详细说明）。
异常处理：在整个过程中，如果出现数据库查询错误、锁获取异常等问题，释放已获取的锁，并返回相应的错误信息给前端，便于前端提示用户。
2. 生成订单签名（sign order in pomelo pay）
查询订单：用户确认预订后，前端将订单 ID 发送给后端。后端根据订单 ID 从数据库中查询对应的初始化订单信息。若未查询到订单记录，返回错误信息给前端，提示订单不存在。
验证订单归属：检查查询到的订单的用户信息（如学号）是否与当前登录用户的信息一致。若不一致，返回错误信息，提示订单不属于该用户。
生成订单签名：调用支付客户端（如 Pomelo Pay 的 SDK）的签名方法，为订单生成签名。签名的生成通常需要使用订单的关键信息（如订单 ID、金额、商品描述等）和支付平台提供的密钥，以确保订单信息的完整性和安全性。
发送签名信息到支付系统：将生成的签名信息、订单信息等封装成请求数据，发送到 Pomelo Pay 支付系统，准备进行支付。同时，记录该请求的相关信息，如请求时间、请求参数等，以便后续的日志分析和问题排查。
异常处理：如果在查询订单、验证订单归属、生成签名或发送请求过程中出现异常，返回相应的错误信息给前端，提示用户支付签名生成失败。
3. 订单初始化（初始化步骤）
验证金额格式：支付系统接收到订单信息后，对订单中的金额进行格式验证。确保金额为正数，且符合支付系统要求的格式（如以分为单位的整数）。若金额格式不符合要求，返回错误信息给前端，提示金额格式错误。
验证第三方服务：根据订单中的 appId（应用 ID），从数据库中查询对应的第三方应用信息。若查询结果为空，说明该第三方服务不存在，返回错误信息给前端，提示第三方服务不可用。
第三方签名校验：使用第三方应用的密钥对订单信息进行签名校验，确保订单信息在传输过程中未被篡改。若签名校验失败，返回错误信息给前端，提示签名验证错误。
创建 Order 对象：若上述验证步骤均通过，创建一个 Order 对象，将用户的 OpenID（第三方用户唯一标识）、NotifyUrl（异步通知地址）、订单 ID、金额、商品描述等信息设置到对象中。
异常处理：在验证过程中，若出现任何错误，记录错误日志，并返回相应的错误信息给前端，提示用户订单初始化失败。
4. 订单创建（create 步骤）
生成订单 ID：使用雪花算法生成一个唯一的 64 位订单 ID。雪花算法生成的 ID 具有趋势递增、不重复的特点，能够保证在分布式系统中生成的订单 ID 全局唯一。将生成的订单 ID 设置到 Order 对象中。
设置订单状态：将订单状态设置为 INIT（初始状态），表示订单已成功创建但尚未开始支付。
记录创建时间和修改时间：将当前时间设置为订单的创建时间和修改时间，便于后续的订单状态跟踪和统计分析。
插入数据库：将 Order 对象插入到数据库的订单表中。在插入过程中，使用数据库的事务机制，确保数据的一致性。若插入失败，抛出业务异常，提示订单创建失败，并回滚事务。
设置跟踪标签：使用 OpenTelemetry 的 Span 对象，设置跟踪标签，标签内容包括订单 ID 和订单状态。通过设置跟踪标签，可以在分布式追踪系统中更清晰地跟踪订单的处理流程，便于后续的性能分析和问题排查。
异常处理：如果插入数据库失败，记录错误日志，回滚事务，并抛出业务异常，提示订单无法创建。
5. 发布订单状态更新事件（publish 步骤）
创建事件对象：创建一个 OrderStatusUpdateEvent 对象，将订单信息和订单状态（INIT）封装到事件对象中。事件对象可以包含订单 ID、订单状态、更新时间等信息，以便订阅者能够准确获取订单状态的变化。
发布事件：将事件对象发布到 Redis 的 rStream 中。rStream 是 Redis 提供的一种消息流数据结构，支持多生产者多消费者模式，能够高效地处理订单状态更新事件的发布和订阅。在发布事件时，记录发布时间和事件内容，便于后续的日志分析。
异常处理：如果发布事件失败，记录错误日志，并进行相应的重试机制。例如，尝试重新发布事件 3 次，若仍失败，则记录最终的错误信息，通知系统管理员进行人工干预。
6. 收银处理（cashier 步骤）
验证签名：前端将用户选择的支付方式和订单信息发送到后端进行收银处理。后端接收到请求后，再次对订单信息进行签名验证，确保信息的完整性和合法性。若签名验证失败，返回错误信息给前端，提示签名验证错误。
设置跟踪标签：使用 OpenTelemetry 的 Span 对象，设置跟踪标签，标签内容包括订单 ID 和订单状态。通过设置跟踪标签，可以在分布式追踪系统中更清晰地跟踪订单的支付流程，便于后续的性能分析和问题排查。
获取分布式锁：使用 Redisson 获取一个分布式锁，锁的名称与订单 ID 相关，例如 paying:{order_id}。尝试获取锁，如果在一定时间内（如 5 秒）未能获取到锁，说明该订单正在被其他线程处理，返回错误信息给前端，提示请勿重复支付。
检查订单状态：获取到锁后，查询数据库，获取订单的当前状态。如果订单状态已结束（如已支付、已取消等），释放锁并返回错误信息给前端，提示当前订单已结束；如果订单状态不是初始状态（INIT），释放锁并返回错误信息给前端，提示请勿重复支付。
更新订单状态：若订单状态符合要求，将订单状态更新为 PAYING（支付中），并更新数据库中的订单信息。在更新过程中，使用数据库的乐观锁机制，确保数据的一致性。若更新失败，释放锁并返回错误信息给前端，提示订单状态更新失败。
选择支付策略：根据用户选择的支付方式（如微信支付、校园一卡通支付等），从支付策略集合中获取相应的支付策略实例。支付策略实例封装了不同支付方式的具体处理逻辑，如调用支付接口、处理支付结果等。
释放锁：无论订单处理是否成功，都要释放分布式锁，避免出现死锁情况。
异常处理：如果在验证签名、获取锁、检查订单状态、更新订单状态或选择支付策略过程中出现异常，释放锁并返回相应的错误信息给前端，提示用户支付处理失败。
7. 再次发布订单状态更新事件（publish 步骤）
创建事件对象：创建一个 OrderStatusUpdateEvent 对象，将订单信息和订单状态（PAYING）封装到事件对象中。
发布事件：将事件对象发布到 Redis 的 rStream 中。在发布事件时，记录发布时间和事件内容，便于后续的日志分析。
异常处理：如果发布事件失败，记录错误日志，并进行相应的重试机制。例如，尝试重新发布事件 3 次，若仍失败，则记录最终的错误信息，通知系统管理员进行人工干预。
8. 校园一卡通收银处理（cashier 步骤）
构建校园一卡通收银参数：根据订单信息和支付方式，构建校园一卡通收银所需的参数对象，如 EcardCashierParam。设置参数对象的相关属性，如快速跳转标志、预支付 ID、设备类型、学生 ID、外部交易号等，并添加扩展参数（如微信的 openId 和第三方应用的微信 ID）。
将订单加入 rDelayedQueue：将订单信息封装成 DelayedOrder 对象，并将其加入到 Redis 的 rDelayedQueue 中，设置延迟时间。延迟时间可以根据业务需求设置，例如在支付超时后触发相应的处理逻辑。在加入队列时，记录加入时间和延迟时间，便于后续的日志分析。
异常处理：如果构建参数或加入延迟队列失败，记录错误日志，并返回相应的错误信息给前端，提示用户校园一卡通收银处理失败。
9. 支付处理（pay 步骤）
获取订单：从 rDelayedQueue 中获取到期的订单信息。使用一个后台线程不断监听 rDelayedQueue，当有订单到期时，将其从队列中取出进行处理。
执行支付操作：根据订单的支付方式，调用相应的支付接口进行支付处理。例如，若为微信支付，调用微信支付的统一下单接口，获取支付二维码或支付链接；若为校园一卡通支付，调用校园一卡通系统的支付接口进行支付。在调用支付接口时，记录请求时间、请求参数和响应结果，便于后续的日志分析和问题排查。
处理支付结果：根据支付接口的返回结果，更新订单的状态（如支付成功、支付失败等），并更新数据库中的订单信息。若支付成功，将订单状态更新为 PAID（已支付），记录支付时间和支付流水号；若支付失败，将订单状态更新为 FAILED（支付失败），记录失败原因。在更新过程中，使用数据库的事务机制，确保数据的一致性。
异步通知订单结果：使用线程池异步执行通知任务，将支付结果以 HTTP POST 请求的方式发送到订单的 NotifyUrl。设置请求的内容类型为 JSON，将订单的 ID、状态、商品信息、金额和修改时间等信息封装成通知体发送。在发送请求时，设置合理的超时时间（如 5 秒），并进行重试机制。若多次重试后仍失败，记录错误日志，通知系统管理员进行人工干预。
异常处理：如果在获取订单、执行支付操作、处理支付结果或通知结果过程中出现异常，记录错误日志，并进行相应的重试机制。若多次重试后仍失败，记录最终的错误信息，通知系统管理员进行人工干预。

### 复杂介绍
面试官您好，接下来我为您详细介绍一下我参与的Pomelo - Pay项目中的支付流程相关工作。

我们这个项目主要服务于南邮小程序的各类支付场景，像水电费充值以及体育场馆预约，涵盖了微信支付和校园E卡通支付。在整个项目流程里，我负责的部分从用户发起体育场馆预约开始。

当用户在前端选择好用户信息、时间段以及体育场馆后，前端会将这些数据发送给后端。后端接收到请求，第一步就是使用Redisson的分布式锁机制，根据用户所选的时间段和体育场馆生成唯一锁键，尝试获取锁。这一步非常关键，它确保同一时间只有一个用户能对该时段和场馆进行操作。如果在5秒内未能获取到锁，就会给前端返回错误信息，提示用户稍后重试。成功获取锁后，系统会查询数据库，检查该场地在所选时间段是否已被占用。要是存在预订记录，就说明场地已被占用，这时会释放锁，并告知前端场地已被预订。若场地未被占用，就会创建一个初始订单对象，把用户信息、时间段、体育场馆等信息存入其中，设置订单初始状态为“INIT”，记录创建时间，再将订单插入数据库，同时用雪花算法生成唯一订单ID。在这一系列操作中，任何环节出错，都会释放锁并返回相应错误信息给前端。

之后到了生成订单签名环节，用户确认预订，前端把订单ID发给后端。后端依据订单ID查询初始化订单信息，若没查到，返回订单不存在的错误。查到后，会验证订单归属，检查订单中的用户信息与当前登录用户是否一致，不一致就提示订单不属于该用户。确认无误后，调用支付客户端的签名方法，结合订单关键信息和支付平台密钥生成签名，再将签名信息连同订单信息一起发送到Pomelo Pay支付系统。这个过程中若出现异常，同样会给前端返回错误提示。

支付系统收到订单信息后，进入订单初始化步骤。系统会先验证金额格式，保证金额为正数且符合以分为单位的整数要求，格式不对就返回错误。接着根据订单中的“appId”查询对应的第三方应用信息，若查不到，说明第三方服务不存在，返回错误。随后使用第三方应用密钥对订单信息进行签名校验，校验失败也返回错误。只有这些验证都通过，才会创建“Order”对象，把用户OpenID、NotifyUrl、订单ID等信息设置进去。

订单创建阶段，用雪花算法生成64位唯一订单ID设置到“Order”对象，将订单状态设为“INIT”，记录创建和修改时间，然后将订单插入数据库。插入时使用事务机制保证数据一致性，若插入失败，抛出业务异常并回滚事务。同时，利用OpenTelemetry的“Span”对象设置包含订单ID和状态的跟踪标签，方便后续分布式追踪。

订单状态更新事件发布时，会创建“OrderStatusUpdateEvent”对象，封装订单信息和“INIT”状态，发布到Redis的“rStream”中。发布失败会记录日志并尝试重新发布3次，若仍失败则通知管理员。

收银处理时，前端将支付方式和订单信息发往后端，后端再次验证签名，签名失败返回错误。接着获取与订单ID相关的分布式锁，5秒内获取不到锁，提示用户请勿重复支付。获取到锁后查询订单当前状态，若订单已结束或不是“INIT”状态，释放锁并返回相应错误。订单状态符合要求，就将其更新为“PAYING”，更新数据库订单信息，更新时使用乐观锁机制保证一致性，失败则释放锁返回错误。然后根据用户选择的支付方式，从支付策略集合中获取对应实例。完成操作后，无论成功与否都释放锁。

之后再次发布订单状态更新事件，创建封装“PAYING”状态的“OrderStatusUpdateEvent”对象，发布到“rStream”，发布失败处理方式与之前一致。

若用户选择校园一卡通支付，后端会构建校园一卡通收银参数对象，设置快速跳转标志、预支付ID等属性及扩展参数，然后将订单信息封装成“DelayedOrder”对象加入Redis的“rDelayedQueue”，设置延迟时间，用于处理支付超时等情况。构建参数或加入队列失败，记录日志并给前端返回错误。

最后支付处理环节，有一个后台线程持续监听“rDelayedQueue”，获取到期订单。根据订单支付方式调用相应支付接口，比如微信支付调用统一下单接口，校园一卡通支付调用对应系统接口，调用时记录请求和响应信息。根据支付接口返回结果更新订单状态到数据库，支付成功设为“PAID”，记录支付时间和流水号，失败设为“FAILED”，记录失败原因，更新时使用事务保证一致性。更新完成后，用线程池异步将支付结果以HTTP POST请求发送到订单的“NotifyUrl”，设置5秒超时时间并进行重试，多次重试失败记录日志通知管理员。

通过参与这个项目，我深入理解了支付系统的复杂流程，在分布式技术、数据一致性保障以及异常处理等方面积累了丰富经验，成功保障了Pomelo - Pay支付流程的稳定运行和高效处理 。 

### 简单介绍
面试官您好，我参与的 Pomelo - Pay 项目是南邮小程序的重要支付模块，主要服务于校内水电费充值、体育场馆预约等场景，支持微信和校园 E 卡通两种支付方式。
以体育场馆预约支付流程为例，整个过程包含多个关键环节。当用户在前端选择好用户信息、时间段和体育场馆并提交请求后，前端会先对输入数据进行初步验证。之后，后端接收请求，使用 Redisson 分布式锁对所选的时间段和体育场馆进行加锁，避免并发问题。同时，我们使用 OpenTelemetry 在锁操作处埋点，记录锁的获取和释放时间，以便后续分析并发控制情况。接着，后端会查询数据库检查场地是否已被占用，若未占用则创建订单并将初始化信息存入数据库，在这些数据库操作处也进行了埋点，方便排查数据库性能和数据一致性问题。
生成订单签名阶段，后端根据前端传来的订单 ID 查询订单信息，验证订单归属后调用支付客户端生成签名并发送到支付系统。此过程中，在支付相关接口调用处进行埋点，记录接口调用的请求和响应信息，有助于分析支付流程的性能。
订单初始化时，系统会验证金额格式、第三方服务和签名，验证通过后创建 Order 对象。随后使用雪花算法生成订单 ID，设置订单状态为 INIT，并将订单信息插入数据库。同时，使用 OpenTelemetry 记录这些操作的详细信息，如操作时间、操作结果等。
为了实现订单状态的实时更新和通知，我们引入了 Redis 的 rStream。当订单状态发生变更时，如从 INIT 变为 PAYING，系统会创建包含订单信息和新状态的事件对象，并将其发布到 rStream。这里在 rStream 消息发布处进行了埋点，记录发布的消息内容和时间。
订单状态跟踪服务和消息推送服务会使用 rTopic 订阅 rStream。订单状态跟踪服务可以实时获取订单状态的更新，及时在前端展示准确的订单状态；消息推送服务则能根据订单状态的变化向用户发送相应的通知，如订单创建成功、支付提醒、支付结果等。在这两个服务订阅 rStream 接收消息时也进行了埋点，方便分析消息传递的情况。
最后，在支付处理环节，根据用户选择的支付方式调用相应的支付接口，处理支付结果并更新订单状态，同时异步通知支付结果。整个过程中，OpenTelemetry 的埋点帮助我们全面监控订单处理流程，快速定位和解决可能出现的问题，确保 Pomelo - Pay 项目的稳定运行和良好的用户体验。

### 关键点
- 小程序端
    - 前端请求体育场地，上rLock锁，优势：实现简单，线程获取锁时间过长自动释放
    - 修改数据库场地状态，生成签名，发送给支付系统
- 支付服务
    - 生成订单（init），雪花算法生成id，检查各个信息，Order加入数据库，并将init和order加入rStream中
    - 收银处理，前端发来支付方式和订单信息，后端再次校验签名，然后获取分布式锁（乐观锁）和订单，检查订单状态，更新订单状态（paying），选择支付策略，更新数据库，释放锁，将paying和order加入到rStream中
    - 生成支付信息发送给前端跳转支付，并将订单加入到rDelayedQueue中
    - 检查是否支付完成，完成则改变订单状态为paid，加入rStream中