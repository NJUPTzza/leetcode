# zj
## 项目
- 1.询问SSO系统是什么样的？
    - 1. 用户访问系统A，若未携带jwt，则判断用户未登录，携带系统A的redirect_uri和client_id，将其重定向到SSO系统
    - 2. 用户在SSO系统输入账号和密码之后，SSO系统会用私钥生成并颁布访问令牌和刷新令牌，并将其重定向回系统A，系统A会用公钥验证令牌
    - 3. 前端拿到访问令牌和刷新令牌后会存起来，后续访问系统B时会携带访问令牌
    - 4. 系统B拿到令牌，用公钥验证令牌合理性 
    - 5. 如果不合法，如超时，则告诉前端，前端再拿着刷新令牌（如果有的话）访问SSO，获取新令牌

- 2.加密算法有哪些？对称加密非对称加密？
    - 1. 我的项目中使用的是非对称加密 ES256（ECDSA - SHA256），是预先配置在后端服务中的，私钥放在SSO服务中，公钥分发给各个服务。ES256安全性强，长度短所以资源消耗小，计算效率高
    - 2. 区别：对称加密，加解密用相同的密钥；非对称加密，公钥加密，只有私钥能解密。
    - 3. 常见加密算法：对称：DSE，AES；非对称：RSA，DSA，ECDSA;

- 3.如何防止二次支付？
    - 支付幂等性
    - 前端ban按钮
    - 雪花算法生成唯一订单ID
    - 分布式锁保证同一订单的一个状态过程只有一个结点处理
    - 将调用支付接口和更新订单状态放在一个事务中
    - 状态机设计，如果订单状态为paid，后续任何支付会报错
    - DelayQueue验证订单状态

- 4.一堆我完全没考虑过的问题？ 

## 八股
- 1.你们项目用的JDK几，新特性？ 
    - 密封类sealed，只允许特定的子类继承或实现
    - 统一的日志api

- 2.你知道JDK17用的什么垃圾回收器吗？ 
    - G1回收器

- 3.介绍一下这个垃圾回收器？
    - 基于“标记-整理”算法实现
    - G1回收的范围是整个Java堆(包括新生代，老年代)

- 4.新生代和老年代都用的标记整理算法吗？ 
    - 是

- 5.你知道这个垃圾回收器回收过程中哪些是阻塞的哪些不是吗？ 
    - 初始标记阶段: 从GC Roots出发标记全部直接子节点，阻塞
    - 可达性分析标记阶段: 从GC Roots开始对堆中对象进行可达性分析，非阻塞
    - 再标记阶段: 重新标记那些在并发标记阶段发生变化的对象，阻塞
    - 清理阶段：清点出有存活对象的分区和没有存活对象的分区，阻塞
    - 复制转移阶段：把活跃对象复制到新内存地址，需要分配新内存和复制对象的成员变量，阻塞最严重

- 6.为什么可达性分析标记阶段是并发的，再标记阶段是阻塞的？
    - 可达性分析标记阶段耗时较长，如果阻塞会有很长停顿时间
    - 再标记阶段为了确保标记的准确性，需要暂停应用程序线程，避免在标记过程中对象的引用关系再次发生变化，从而能够准确地重新标记那些在可达性分析标记阶段发生变化的对象。

- 7.mysql事务的特性 ?
    - ACID
    - 原子性：一个事务中的所有操作，要么全部完成，要么全部不完成
    - 一致性：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态
    - 隔离性：多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的
    - 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

- 8.如何保证redis和mysql数据缓存一致性问题？ 
    - 延迟双删

- 9.你知道先更新数据库，再删除缓存，什么时候会出现数据不一致吗？ 

- 10.http用的什么版本？
    - 一般默认的web框架用的都是默认的HTTP/2

- 11.你知道http协议和tcp协议有什么区别吗？

- 12.http协议优化方面做了哪些？
    - HTTP/1.1
        - 尽量避免发送 HTTP 请求
        > 将请求响应的数据缓存在本地

        - 在需要发送 HTTP 请求时，考虑如何减少请求次数：
        > 减少重定向请求次数，合并请求，延迟发送请求

        - 减少服务器的 HTTP 响应的数据大小
        > 无损压缩，有损压缩

    - HTTP/2
        - 开发了 HPACK 算法压缩头部
        - 将文本格式改成二进制格式传输数据
        - 多个 Stream 复用一条 TCP 连接，达到并发的效果，解决队头阻塞问题
        - 服务器能主动推送资源，减少消息传递次数

    - HTTP/3
        - 传输层用了UDP协议
        - 应用层基于UDP开发了QUIC协议
        - 无队头阻塞，更快的连接建立，连接迁移

- 13.tcp协议优化方面做了哪些？

## 算法
- 两个有序数组找第K大的数字 
- 时间复杂度 
- 优化方法 

# mt

